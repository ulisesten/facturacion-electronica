// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CFDV33_HXX
#define CFDV33_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace XDSToXML
{
  class Comprobante;
  class CfdiRelacionados;
  class Emisor;
  class Receptor;
  class Conceptos;
  class Impuestos;
  class Complemento;
  class Addenda;
  class Version;
  class Serie;
  class Folio;
  class Sello;
  class NoCertificado;
  class Certificado;
  class CondicionesDePago;
  class TipoCambio;
  class Confirmacion;
  class CfdiRelacionado;
  class Nombre;
  class NumRegIdTrib;
  class Concepto;
  class Retenciones;
  class Traslados;
  class UUID;
  class Impuestos1;
  class InformacionAduanera;
  class CuentaPredial;
  class ComplementoConcepto;
  class Parte;
  class NoIdentificacion;
  class Cantidad;
  class Unidad;
  class Descripcion;
  class Retencion;
  class Traslado;
  class Traslados1;
  class Retenciones1;
  class NumeroPedimento;
  class Numero;
  class InformacionAduanera1;
  class TasaOCuota;
  class Traslado1;
  class Retencion1;
  class Base;
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "catCFDI.hpp"

#include "tdCFDI.hpp"

namespace XDSToXML
{
  class Comprobante: public ::xml_schema::type
  {
    public:
    // CfdiRelacionados
    //
    typedef ::XDSToXML::CfdiRelacionados CfdiRelacionados_type;
    typedef ::xsd::cxx::tree::optional< CfdiRelacionados_type > CfdiRelacionados_optional;
    typedef ::xsd::cxx::tree::traits< CfdiRelacionados_type, char > CfdiRelacionados_traits;

    const CfdiRelacionados_optional&
    CfdiRelacionados () const;

    CfdiRelacionados_optional&
    CfdiRelacionados ();

    void
    CfdiRelacionados (const CfdiRelacionados_type& x);

    void
    CfdiRelacionados (const CfdiRelacionados_optional& x);

    void
    CfdiRelacionados (::std::auto_ptr< CfdiRelacionados_type > p);

    // Emisor
    //
    typedef ::XDSToXML::Emisor Emisor_type;
    typedef ::xsd::cxx::tree::traits< Emisor_type, char > Emisor_traits;

    const Emisor_type&
    Emisor () const;

    Emisor_type&
    Emisor ();

    void
    Emisor (const Emisor_type& x);

    void
    Emisor (::std::auto_ptr< Emisor_type > p);

    // Receptor
    //
    typedef ::XDSToXML::Receptor Receptor_type;
    typedef ::xsd::cxx::tree::traits< Receptor_type, char > Receptor_traits;

    const Receptor_type&
    Receptor () const;

    Receptor_type&
    Receptor ();

    void
    Receptor (const Receptor_type& x);

    void
    Receptor (::std::auto_ptr< Receptor_type > p);

    // Conceptos
    //
    typedef ::XDSToXML::Conceptos Conceptos_type;
    typedef ::xsd::cxx::tree::traits< Conceptos_type, char > Conceptos_traits;

    const Conceptos_type&
    Conceptos () const;

    Conceptos_type&
    Conceptos ();

    void
    Conceptos (const Conceptos_type& x);

    void
    Conceptos (::std::auto_ptr< Conceptos_type > p);

    // Impuestos
    //
    typedef ::XDSToXML::Impuestos Impuestos_type;
    typedef ::xsd::cxx::tree::optional< Impuestos_type > Impuestos_optional;
    typedef ::xsd::cxx::tree::traits< Impuestos_type, char > Impuestos_traits;

    const Impuestos_optional&
    Impuestos () const;

    Impuestos_optional&
    Impuestos ();

    void
    Impuestos (const Impuestos_type& x);

    void
    Impuestos (const Impuestos_optional& x);

    void
    Impuestos (::std::auto_ptr< Impuestos_type > p);

    // Complemento
    //
    typedef ::XDSToXML::Complemento Complemento_type;
    typedef ::xsd::cxx::tree::sequence< Complemento_type > Complemento_sequence;
    typedef Complemento_sequence::iterator Complemento_iterator;
    typedef Complemento_sequence::const_iterator Complemento_const_iterator;
    typedef ::xsd::cxx::tree::traits< Complemento_type, char > Complemento_traits;

    const Complemento_sequence&
    Complemento () const;

    Complemento_sequence&
    Complemento ();

    void
    Complemento (const Complemento_sequence& s);

    // Addenda
    //
    typedef ::XDSToXML::Addenda Addenda_type;
    typedef ::xsd::cxx::tree::optional< Addenda_type > Addenda_optional;
    typedef ::xsd::cxx::tree::traits< Addenda_type, char > Addenda_traits;

    const Addenda_optional&
    Addenda () const;

    Addenda_optional&
    Addenda ();

    void
    Addenda (const Addenda_type& x);

    void
    Addenda (const Addenda_optional& x);

    void
    Addenda (::std::auto_ptr< Addenda_type > p);

    // Version
    //
    typedef ::XDSToXML::Version Version_type;
    typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

    const Version_type&
    Version () const;

    static const Version_type&
    Version_default_value ();

    // Serie
    //
    typedef ::XDSToXML::Serie Serie_type;
    typedef ::xsd::cxx::tree::optional< Serie_type > Serie_optional;
    typedef ::xsd::cxx::tree::traits< Serie_type, char > Serie_traits;

    const Serie_optional&
    Serie () const;

    Serie_optional&
    Serie ();

    void
    Serie (const Serie_type& x);

    void
    Serie (const Serie_optional& x);

    void
    Serie (::std::auto_ptr< Serie_type > p);

    // Folio
    //
    typedef ::XDSToXML::Folio Folio_type;
    typedef ::xsd::cxx::tree::optional< Folio_type > Folio_optional;
    typedef ::xsd::cxx::tree::traits< Folio_type, char > Folio_traits;

    const Folio_optional&
    Folio () const;

    Folio_optional&
    Folio ();

    void
    Folio (const Folio_type& x);

    void
    Folio (const Folio_optional& x);

    void
    Folio (::std::auto_ptr< Folio_type > p);

    // Fecha
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_FechaH Fecha_type;
    typedef ::xsd::cxx::tree::traits< Fecha_type, char > Fecha_traits;

    const Fecha_type&
    Fecha () const;

    Fecha_type&
    Fecha ();

    void
    Fecha (const Fecha_type& x);

    void
    Fecha (::std::auto_ptr< Fecha_type > p);

    // Sello
    //
    typedef ::XDSToXML::Sello Sello_type;
    typedef ::xsd::cxx::tree::traits< Sello_type, char > Sello_traits;

    const Sello_type&
    Sello () const;

    Sello_type&
    Sello ();

    void
    Sello (const Sello_type& x);

    void
    Sello (::std::auto_ptr< Sello_type > p);

    // FormaPago
    //
    typedef ::sitio_internet::cfd::catalogos::c_FormaPago FormaPago_type;
    typedef ::xsd::cxx::tree::optional< FormaPago_type > FormaPago_optional;
    typedef ::xsd::cxx::tree::traits< FormaPago_type, char > FormaPago_traits;

    const FormaPago_optional&
    FormaPago () const;

    FormaPago_optional&
    FormaPago ();

    void
    FormaPago (const FormaPago_type& x);

    void
    FormaPago (const FormaPago_optional& x);

    void
    FormaPago (::std::auto_ptr< FormaPago_type > p);

    // NoCertificado
    //
    typedef ::XDSToXML::NoCertificado NoCertificado_type;
    typedef ::xsd::cxx::tree::traits< NoCertificado_type, char > NoCertificado_traits;

    const NoCertificado_type&
    NoCertificado () const;

    NoCertificado_type&
    NoCertificado ();

    void
    NoCertificado (const NoCertificado_type& x);

    void
    NoCertificado (::std::auto_ptr< NoCertificado_type > p);

    // Certificado
    //
    typedef ::XDSToXML::Certificado Certificado_type;
    typedef ::xsd::cxx::tree::traits< Certificado_type, char > Certificado_traits;

    const Certificado_type&
    Certificado () const;

    Certificado_type&
    Certificado ();

    void
    Certificado (const Certificado_type& x);

    void
    Certificado (::std::auto_ptr< Certificado_type > p);

    // CondicionesDePago
    //
    typedef ::XDSToXML::CondicionesDePago CondicionesDePago_type;
    typedef ::xsd::cxx::tree::optional< CondicionesDePago_type > CondicionesDePago_optional;
    typedef ::xsd::cxx::tree::traits< CondicionesDePago_type, char > CondicionesDePago_traits;

    const CondicionesDePago_optional&
    CondicionesDePago () const;

    CondicionesDePago_optional&
    CondicionesDePago ();

    void
    CondicionesDePago (const CondicionesDePago_type& x);

    void
    CondicionesDePago (const CondicionesDePago_optional& x);

    void
    CondicionesDePago (::std::auto_ptr< CondicionesDePago_type > p);

    // SubTotal
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe SubTotal_type;
    typedef ::xsd::cxx::tree::traits< SubTotal_type, char > SubTotal_traits;

    const SubTotal_type&
    SubTotal () const;

    SubTotal_type&
    SubTotal ();

    void
    SubTotal (const SubTotal_type& x);

    void
    SubTotal (::std::auto_ptr< SubTotal_type > p);

    // Descuento
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Descuento_type;
    typedef ::xsd::cxx::tree::optional< Descuento_type > Descuento_optional;
    typedef ::xsd::cxx::tree::traits< Descuento_type, char > Descuento_traits;

    const Descuento_optional&
    Descuento () const;

    Descuento_optional&
    Descuento ();

    void
    Descuento (const Descuento_type& x);

    void
    Descuento (const Descuento_optional& x);

    void
    Descuento (::std::auto_ptr< Descuento_type > p);

    // Moneda
    //
    typedef ::sitio_internet::cfd::catalogos::c_Moneda Moneda_type;
    typedef ::xsd::cxx::tree::traits< Moneda_type, char > Moneda_traits;

    const Moneda_type&
    Moneda () const;

    Moneda_type&
    Moneda ();

    void
    Moneda (const Moneda_type& x);

    void
    Moneda (::std::auto_ptr< Moneda_type > p);

    // TipoCambio
    //
    typedef ::XDSToXML::TipoCambio TipoCambio_type;
    typedef ::xsd::cxx::tree::optional< TipoCambio_type > TipoCambio_optional;
    typedef ::xsd::cxx::tree::traits< TipoCambio_type, char > TipoCambio_traits;

    const TipoCambio_optional&
    TipoCambio () const;

    TipoCambio_optional&
    TipoCambio ();

    void
    TipoCambio (const TipoCambio_type& x);

    void
    TipoCambio (const TipoCambio_optional& x);

    void
    TipoCambio (::std::auto_ptr< TipoCambio_type > p);

    // Total
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Total_type;
    typedef ::xsd::cxx::tree::traits< Total_type, char > Total_traits;

    const Total_type&
    Total () const;

    Total_type&
    Total ();

    void
    Total (const Total_type& x);

    void
    Total (::std::auto_ptr< Total_type > p);

    // TipoDeComprobante
    //
    typedef ::sitio_internet::cfd::catalogos::c_TipoDeComprobante TipoDeComprobante_type;
    typedef ::xsd::cxx::tree::traits< TipoDeComprobante_type, char > TipoDeComprobante_traits;

    const TipoDeComprobante_type&
    TipoDeComprobante () const;

    TipoDeComprobante_type&
    TipoDeComprobante ();

    void
    TipoDeComprobante (const TipoDeComprobante_type& x);

    void
    TipoDeComprobante (::std::auto_ptr< TipoDeComprobante_type > p);

    // MetodoPago
    //
    typedef ::sitio_internet::cfd::catalogos::c_MetodoPago MetodoPago_type;
    typedef ::xsd::cxx::tree::optional< MetodoPago_type > MetodoPago_optional;
    typedef ::xsd::cxx::tree::traits< MetodoPago_type, char > MetodoPago_traits;

    const MetodoPago_optional&
    MetodoPago () const;

    MetodoPago_optional&
    MetodoPago ();

    void
    MetodoPago (const MetodoPago_type& x);

    void
    MetodoPago (const MetodoPago_optional& x);

    void
    MetodoPago (::std::auto_ptr< MetodoPago_type > p);

    // LugarExpedicion
    //
    typedef ::sitio_internet::cfd::catalogos::c_CodigoPostal LugarExpedicion_type;
    typedef ::xsd::cxx::tree::traits< LugarExpedicion_type, char > LugarExpedicion_traits;

    const LugarExpedicion_type&
    LugarExpedicion () const;

    LugarExpedicion_type&
    LugarExpedicion ();

    void
    LugarExpedicion (const LugarExpedicion_type& x);

    void
    LugarExpedicion (::std::auto_ptr< LugarExpedicion_type > p);

    // Confirmacion
    //
    typedef ::XDSToXML::Confirmacion Confirmacion_type;
    typedef ::xsd::cxx::tree::optional< Confirmacion_type > Confirmacion_optional;
    typedef ::xsd::cxx::tree::traits< Confirmacion_type, char > Confirmacion_traits;

    const Confirmacion_optional&
    Confirmacion () const;

    Confirmacion_optional&
    Confirmacion ();

    void
    Confirmacion (const Confirmacion_type& x);

    void
    Confirmacion (const Confirmacion_optional& x);

    void
    Confirmacion (::std::auto_ptr< Confirmacion_type > p);

    // Constructors.
    //
    Comprobante (const Emisor_type&,
                 const Receptor_type&,
                 const Conceptos_type&,
                 const Fecha_type&,
                 const Sello_type&,
                 const NoCertificado_type&,
                 const Certificado_type&,
                 const SubTotal_type&,
                 const Moneda_type&,
                 const Total_type&,
                 const TipoDeComprobante_type&,
                 const LugarExpedicion_type&);

    Comprobante (::std::auto_ptr< Emisor_type >,
                 ::std::auto_ptr< Receptor_type >,
                 ::std::auto_ptr< Conceptos_type >,
                 const Fecha_type&,
                 const Sello_type&,
                 const NoCertificado_type&,
                 const Certificado_type&,
                 const SubTotal_type&,
                 const Moneda_type&,
                 const Total_type&,
                 const TipoDeComprobante_type&,
                 const LugarExpedicion_type&);

    Comprobante (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Comprobante (const Comprobante& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual Comprobante*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Comprobante&
    operator= (const Comprobante& x);

    virtual 
    ~Comprobante ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CfdiRelacionados_optional CfdiRelacionados_;
    ::xsd::cxx::tree::one< Emisor_type > Emisor_;
    ::xsd::cxx::tree::one< Receptor_type > Receptor_;
    ::xsd::cxx::tree::one< Conceptos_type > Conceptos_;
    Impuestos_optional Impuestos_;
    Complemento_sequence Complemento_;
    Addenda_optional Addenda_;
    ::xsd::cxx::tree::one< Version_type > Version_;
    static const Version_type Version_default_value_;
    Serie_optional Serie_;
    Folio_optional Folio_;
    ::xsd::cxx::tree::one< Fecha_type > Fecha_;
    ::xsd::cxx::tree::one< Sello_type > Sello_;
    FormaPago_optional FormaPago_;
    ::xsd::cxx::tree::one< NoCertificado_type > NoCertificado_;
    ::xsd::cxx::tree::one< Certificado_type > Certificado_;
    CondicionesDePago_optional CondicionesDePago_;
    ::xsd::cxx::tree::one< SubTotal_type > SubTotal_;
    Descuento_optional Descuento_;
    ::xsd::cxx::tree::one< Moneda_type > Moneda_;
    TipoCambio_optional TipoCambio_;
    ::xsd::cxx::tree::one< Total_type > Total_;
    ::xsd::cxx::tree::one< TipoDeComprobante_type > TipoDeComprobante_;
    MetodoPago_optional MetodoPago_;
    ::xsd::cxx::tree::one< LugarExpedicion_type > LugarExpedicion_;
    Confirmacion_optional Confirmacion_;
  };

  class CfdiRelacionados: public ::xml_schema::type
  {
    public:
    // CfdiRelacionado
    //
    typedef ::XDSToXML::CfdiRelacionado CfdiRelacionado_type;
    typedef ::xsd::cxx::tree::sequence< CfdiRelacionado_type > CfdiRelacionado_sequence;
    typedef CfdiRelacionado_sequence::iterator CfdiRelacionado_iterator;
    typedef CfdiRelacionado_sequence::const_iterator CfdiRelacionado_const_iterator;
    typedef ::xsd::cxx::tree::traits< CfdiRelacionado_type, char > CfdiRelacionado_traits;

    const CfdiRelacionado_sequence&
    CfdiRelacionado () const;

    CfdiRelacionado_sequence&
    CfdiRelacionado ();

    void
    CfdiRelacionado (const CfdiRelacionado_sequence& s);

    // TipoRelacion
    //
    typedef ::sitio_internet::cfd::catalogos::c_TipoRelacion TipoRelacion_type;
    typedef ::xsd::cxx::tree::traits< TipoRelacion_type, char > TipoRelacion_traits;

    const TipoRelacion_type&
    TipoRelacion () const;

    TipoRelacion_type&
    TipoRelacion ();

    void
    TipoRelacion (const TipoRelacion_type& x);

    void
    TipoRelacion (::std::auto_ptr< TipoRelacion_type > p);

    // Constructors.
    //
    CfdiRelacionados (const TipoRelacion_type&);

    CfdiRelacionados (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    CfdiRelacionados (const CfdiRelacionados& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual CfdiRelacionados*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CfdiRelacionados&
    operator= (const CfdiRelacionados& x);

    virtual 
    ~CfdiRelacionados ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    CfdiRelacionado_sequence CfdiRelacionado_;
    ::xsd::cxx::tree::one< TipoRelacion_type > TipoRelacion_;
  };

  class Emisor: public ::xml_schema::type
  {
    public:
    // Rfc
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_RFC Rfc_type;
    typedef ::xsd::cxx::tree::traits< Rfc_type, char > Rfc_traits;

    const Rfc_type&
    Rfc () const;

    Rfc_type&
    Rfc ();

    void
    Rfc (const Rfc_type& x);

    void
    Rfc (::std::auto_ptr< Rfc_type > p);

    // Nombre
    //
    typedef ::XDSToXML::Nombre Nombre_type;
    typedef ::xsd::cxx::tree::optional< Nombre_type > Nombre_optional;
    typedef ::xsd::cxx::tree::traits< Nombre_type, char > Nombre_traits;

    const Nombre_optional&
    Nombre () const;

    Nombre_optional&
    Nombre ();

    void
    Nombre (const Nombre_type& x);

    void
    Nombre (const Nombre_optional& x);

    void
    Nombre (::std::auto_ptr< Nombre_type > p);

    // RegimenFiscal
    //
    typedef ::sitio_internet::cfd::catalogos::c_RegimenFiscal RegimenFiscal_type;
    typedef ::xsd::cxx::tree::traits< RegimenFiscal_type, char > RegimenFiscal_traits;

    const RegimenFiscal_type&
    RegimenFiscal () const;

    RegimenFiscal_type&
    RegimenFiscal ();

    void
    RegimenFiscal (const RegimenFiscal_type& x);

    void
    RegimenFiscal (::std::auto_ptr< RegimenFiscal_type > p);

    // Constructors.
    //
    Emisor (const Rfc_type&,
            const RegimenFiscal_type&);

    Emisor (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Emisor (const Emisor& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Emisor*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Emisor&
    operator= (const Emisor& x);

    virtual 
    ~Emisor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Rfc_type > Rfc_;
    Nombre_optional Nombre_;
    ::xsd::cxx::tree::one< RegimenFiscal_type > RegimenFiscal_;
  };

  class Receptor: public ::xml_schema::type
  {
    public:
    // Rfc
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_RFC Rfc_type;
    typedef ::xsd::cxx::tree::traits< Rfc_type, char > Rfc_traits;

    const Rfc_type&
    Rfc () const;

    Rfc_type&
    Rfc ();

    void
    Rfc (const Rfc_type& x);

    void
    Rfc (::std::auto_ptr< Rfc_type > p);

    // Nombre
    //
    typedef ::XDSToXML::Nombre Nombre_type;
    typedef ::xsd::cxx::tree::optional< Nombre_type > Nombre_optional;
    typedef ::xsd::cxx::tree::traits< Nombre_type, char > Nombre_traits;

    const Nombre_optional&
    Nombre () const;

    Nombre_optional&
    Nombre ();

    void
    Nombre (const Nombre_type& x);

    void
    Nombre (const Nombre_optional& x);

    void
    Nombre (::std::auto_ptr< Nombre_type > p);

    // ResidenciaFiscal
    //
    typedef ::sitio_internet::cfd::catalogos::c_Pais ResidenciaFiscal_type;
    typedef ::xsd::cxx::tree::optional< ResidenciaFiscal_type > ResidenciaFiscal_optional;
    typedef ::xsd::cxx::tree::traits< ResidenciaFiscal_type, char > ResidenciaFiscal_traits;

    const ResidenciaFiscal_optional&
    ResidenciaFiscal () const;

    ResidenciaFiscal_optional&
    ResidenciaFiscal ();

    void
    ResidenciaFiscal (const ResidenciaFiscal_type& x);

    void
    ResidenciaFiscal (const ResidenciaFiscal_optional& x);

    void
    ResidenciaFiscal (::std::auto_ptr< ResidenciaFiscal_type > p);

    // NumRegIdTrib
    //
    typedef ::XDSToXML::NumRegIdTrib NumRegIdTrib_type;
    typedef ::xsd::cxx::tree::optional< NumRegIdTrib_type > NumRegIdTrib_optional;
    typedef ::xsd::cxx::tree::traits< NumRegIdTrib_type, char > NumRegIdTrib_traits;

    const NumRegIdTrib_optional&
    NumRegIdTrib () const;

    NumRegIdTrib_optional&
    NumRegIdTrib ();

    void
    NumRegIdTrib (const NumRegIdTrib_type& x);

    void
    NumRegIdTrib (const NumRegIdTrib_optional& x);

    void
    NumRegIdTrib (::std::auto_ptr< NumRegIdTrib_type > p);

    // UsoCFDI
    //
    typedef ::sitio_internet::cfd::catalogos::c_UsoCFDI UsoCFDI_type;
    typedef ::xsd::cxx::tree::traits< UsoCFDI_type, char > UsoCFDI_traits;

    const UsoCFDI_type&
    UsoCFDI () const;

    UsoCFDI_type&
    UsoCFDI ();

    void
    UsoCFDI (const UsoCFDI_type& x);

    void
    UsoCFDI (::std::auto_ptr< UsoCFDI_type > p);

    // Constructors.
    //
    Receptor (const Rfc_type&,
              const UsoCFDI_type&);

    Receptor (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Receptor (const Receptor& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Receptor*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Receptor&
    operator= (const Receptor& x);

    virtual 
    ~Receptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Rfc_type > Rfc_;
    Nombre_optional Nombre_;
    ResidenciaFiscal_optional ResidenciaFiscal_;
    NumRegIdTrib_optional NumRegIdTrib_;
    ::xsd::cxx::tree::one< UsoCFDI_type > UsoCFDI_;
  };

  class Conceptos: public ::xml_schema::type
  {
    public:
    // Concepto
    //
    typedef ::XDSToXML::Concepto Concepto_type;
    typedef ::xsd::cxx::tree::sequence< Concepto_type > Concepto_sequence;
    typedef Concepto_sequence::iterator Concepto_iterator;
    typedef Concepto_sequence::const_iterator Concepto_const_iterator;
    typedef ::xsd::cxx::tree::traits< Concepto_type, char > Concepto_traits;

    const Concepto_sequence&
    Concepto () const;

    Concepto_sequence&
    Concepto ();

    void
    Concepto (const Concepto_sequence& s);

    // Constructors.
    //
    Conceptos ();

    Conceptos (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Conceptos (const Conceptos& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Conceptos*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Conceptos&
    operator= (const Conceptos& x);

    virtual 
    ~Conceptos ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Concepto_sequence Concepto_;
  };

  class Impuestos: public ::xml_schema::type
  {
    public:
    // Retenciones
    //
    typedef ::XDSToXML::Retenciones Retenciones_type;
    typedef ::xsd::cxx::tree::optional< Retenciones_type > Retenciones_optional;
    typedef ::xsd::cxx::tree::traits< Retenciones_type, char > Retenciones_traits;

    const Retenciones_optional&
    Retenciones () const;

    Retenciones_optional&
    Retenciones ();

    void
    Retenciones (const Retenciones_type& x);

    void
    Retenciones (const Retenciones_optional& x);

    void
    Retenciones (::std::auto_ptr< Retenciones_type > p);

    // Traslados
    //
    typedef ::XDSToXML::Traslados Traslados_type;
    typedef ::xsd::cxx::tree::optional< Traslados_type > Traslados_optional;
    typedef ::xsd::cxx::tree::traits< Traslados_type, char > Traslados_traits;

    const Traslados_optional&
    Traslados () const;

    Traslados_optional&
    Traslados ();

    void
    Traslados (const Traslados_type& x);

    void
    Traslados (const Traslados_optional& x);

    void
    Traslados (::std::auto_ptr< Traslados_type > p);

    // TotalImpuestosRetenidos
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe TotalImpuestosRetenidos_type;
    typedef ::xsd::cxx::tree::optional< TotalImpuestosRetenidos_type > TotalImpuestosRetenidos_optional;
    typedef ::xsd::cxx::tree::traits< TotalImpuestosRetenidos_type, char > TotalImpuestosRetenidos_traits;

    const TotalImpuestosRetenidos_optional&
    TotalImpuestosRetenidos () const;

    TotalImpuestosRetenidos_optional&
    TotalImpuestosRetenidos ();

    void
    TotalImpuestosRetenidos (const TotalImpuestosRetenidos_type& x);

    void
    TotalImpuestosRetenidos (const TotalImpuestosRetenidos_optional& x);

    void
    TotalImpuestosRetenidos (::std::auto_ptr< TotalImpuestosRetenidos_type > p);

    // TotalImpuestosTrasladados
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe TotalImpuestosTrasladados_type;
    typedef ::xsd::cxx::tree::optional< TotalImpuestosTrasladados_type > TotalImpuestosTrasladados_optional;
    typedef ::xsd::cxx::tree::traits< TotalImpuestosTrasladados_type, char > TotalImpuestosTrasladados_traits;

    const TotalImpuestosTrasladados_optional&
    TotalImpuestosTrasladados () const;

    TotalImpuestosTrasladados_optional&
    TotalImpuestosTrasladados ();

    void
    TotalImpuestosTrasladados (const TotalImpuestosTrasladados_type& x);

    void
    TotalImpuestosTrasladados (const TotalImpuestosTrasladados_optional& x);

    void
    TotalImpuestosTrasladados (::std::auto_ptr< TotalImpuestosTrasladados_type > p);

    // Constructors.
    //
    Impuestos ();

    Impuestos (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Impuestos (const Impuestos& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Impuestos*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Impuestos&
    operator= (const Impuestos& x);

    virtual 
    ~Impuestos ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Retenciones_optional Retenciones_;
    Traslados_optional Traslados_;
    TotalImpuestosRetenidos_optional TotalImpuestosRetenidos_;
    TotalImpuestosTrasladados_optional TotalImpuestosTrasladados_;
  };

  class Complemento: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    Complemento ();

    Complemento (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Complemento (const Complemento& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual Complemento*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Complemento ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
  };

  class Addenda: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    Addenda ();

    Addenda (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Addenda (const Addenda& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Addenda*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Addenda ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
  };

  class Version: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Version ();

    Version (const char*);

    Version (const ::std::string&);

    Version (const ::xml_schema::string&);

    Version (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const Version& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Version*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Version ();
  };

  class Serie: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Serie ();

    Serie (const char*);

    Serie (const ::std::string&);

    Serie (const ::xml_schema::string&);

    Serie (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Serie (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Serie (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Serie (const Serie& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Serie*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Serie ();
  };

  class Folio: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Folio ();

    Folio (const char*);

    Folio (const ::std::string&);

    Folio (const ::xml_schema::string&);

    Folio (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Folio (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Folio (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Folio (const Folio& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Folio*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Folio ();
  };

  class Sello: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Sello ();

    Sello (const char*);

    Sello (const ::std::string&);

    Sello (const ::xml_schema::string&);

    Sello (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Sello (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Sello (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Sello (const Sello& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Sello*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Sello ();
  };

  class NoCertificado: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    NoCertificado ();

    NoCertificado (const char*);

    NoCertificado (const ::std::string&);

    NoCertificado (const ::xml_schema::string&);

    NoCertificado (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    NoCertificado (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    NoCertificado (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    NoCertificado (const NoCertificado& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual NoCertificado*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~NoCertificado ();
  };

  class Certificado: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Certificado ();

    Certificado (const char*);

    Certificado (const ::std::string&);

    Certificado (const ::xml_schema::string&);

    Certificado (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Certificado (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Certificado (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Certificado (const Certificado& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual Certificado*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Certificado ();
  };

  class CondicionesDePago: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    CondicionesDePago ();

    CondicionesDePago (const char*);

    CondicionesDePago (const ::std::string&);

    CondicionesDePago (const ::xml_schema::string&);

    CondicionesDePago (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CondicionesDePago (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CondicionesDePago (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    CondicionesDePago (const CondicionesDePago& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual CondicionesDePago*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~CondicionesDePago ();
  };

  class TipoCambio: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    TipoCambio (const ::xml_schema::decimal&);

    TipoCambio (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TipoCambio (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TipoCambio (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TipoCambio (const TipoCambio& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual TipoCambio*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TipoCambio ();
  };

  class Confirmacion: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Confirmacion ();

    Confirmacion (const char*);

    Confirmacion (const ::std::string&);

    Confirmacion (const ::xml_schema::string&);

    Confirmacion (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Confirmacion (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Confirmacion (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Confirmacion (const Confirmacion& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual Confirmacion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Confirmacion ();
  };

  class CfdiRelacionado: public ::xml_schema::type
  {
    public:
    // UUID
    //
    typedef ::XDSToXML::UUID UUID_type;
    typedef ::xsd::cxx::tree::traits< UUID_type, char > UUID_traits;

    const UUID_type&
    UUID () const;

    UUID_type&
    UUID ();

    void
    UUID (const UUID_type& x);

    void
    UUID (::std::auto_ptr< UUID_type > p);

    // Constructors.
    //
    CfdiRelacionado (const UUID_type&);

    CfdiRelacionado (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    CfdiRelacionado (const CfdiRelacionado& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual CfdiRelacionado*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CfdiRelacionado&
    operator= (const CfdiRelacionado& x);

    virtual 
    ~CfdiRelacionado ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< UUID_type > UUID_;
  };

  class Nombre: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Nombre ();

    Nombre (const char*);

    Nombre (const ::std::string&);

    Nombre (const ::xml_schema::string&);

    Nombre (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Nombre (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Nombre (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Nombre (const Nombre& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Nombre*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Nombre ();
  };

  class NumRegIdTrib: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    NumRegIdTrib ();

    NumRegIdTrib (const char*);

    NumRegIdTrib (const ::std::string&);

    NumRegIdTrib (const ::xml_schema::string&);

    NumRegIdTrib (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    NumRegIdTrib (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    NumRegIdTrib (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    NumRegIdTrib (const NumRegIdTrib& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual NumRegIdTrib*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~NumRegIdTrib ();
  };

  class Concepto: public ::xml_schema::type
  {
    public:
    // Impuestos
    //
    typedef ::XDSToXML::Impuestos1 Impuestos_type;
    typedef ::xsd::cxx::tree::optional< Impuestos_type > Impuestos_optional;
    typedef ::xsd::cxx::tree::traits< Impuestos_type, char > Impuestos_traits;

    const Impuestos_optional&
    Impuestos () const;

    Impuestos_optional&
    Impuestos ();

    void
    Impuestos (const Impuestos_type& x);

    void
    Impuestos (const Impuestos_optional& x);

    void
    Impuestos (::std::auto_ptr< Impuestos_type > p);

    // InformacionAduanera
    //
    typedef ::XDSToXML::InformacionAduanera InformacionAduanera_type;
    typedef ::xsd::cxx::tree::sequence< InformacionAduanera_type > InformacionAduanera_sequence;
    typedef InformacionAduanera_sequence::iterator InformacionAduanera_iterator;
    typedef InformacionAduanera_sequence::const_iterator InformacionAduanera_const_iterator;
    typedef ::xsd::cxx::tree::traits< InformacionAduanera_type, char > InformacionAduanera_traits;

    const InformacionAduanera_sequence&
    InformacionAduanera () const;

    InformacionAduanera_sequence&
    InformacionAduanera ();

    void
    InformacionAduanera (const InformacionAduanera_sequence& s);

    // CuentaPredial
    //
    typedef ::XDSToXML::CuentaPredial CuentaPredial_type;
    typedef ::xsd::cxx::tree::optional< CuentaPredial_type > CuentaPredial_optional;
    typedef ::xsd::cxx::tree::traits< CuentaPredial_type, char > CuentaPredial_traits;

    const CuentaPredial_optional&
    CuentaPredial () const;

    CuentaPredial_optional&
    CuentaPredial ();

    void
    CuentaPredial (const CuentaPredial_type& x);

    void
    CuentaPredial (const CuentaPredial_optional& x);

    void
    CuentaPredial (::std::auto_ptr< CuentaPredial_type > p);

    // ComplementoConcepto
    //
    typedef ::XDSToXML::ComplementoConcepto ComplementoConcepto_type;
    typedef ::xsd::cxx::tree::optional< ComplementoConcepto_type > ComplementoConcepto_optional;
    typedef ::xsd::cxx::tree::traits< ComplementoConcepto_type, char > ComplementoConcepto_traits;

    const ComplementoConcepto_optional&
    ComplementoConcepto () const;

    ComplementoConcepto_optional&
    ComplementoConcepto ();

    void
    ComplementoConcepto (const ComplementoConcepto_type& x);

    void
    ComplementoConcepto (const ComplementoConcepto_optional& x);

    void
    ComplementoConcepto (::std::auto_ptr< ComplementoConcepto_type > p);

    // Parte
    //
    typedef ::XDSToXML::Parte Parte_type;
    typedef ::xsd::cxx::tree::sequence< Parte_type > Parte_sequence;
    typedef Parte_sequence::iterator Parte_iterator;
    typedef Parte_sequence::const_iterator Parte_const_iterator;
    typedef ::xsd::cxx::tree::traits< Parte_type, char > Parte_traits;

    const Parte_sequence&
    Parte () const;

    Parte_sequence&
    Parte ();

    void
    Parte (const Parte_sequence& s);

    // ClaveProdServ
    //
    typedef ::sitio_internet::cfd::catalogos::c_ClaveProdServ ClaveProdServ_type;
    typedef ::xsd::cxx::tree::traits< ClaveProdServ_type, char > ClaveProdServ_traits;

    const ClaveProdServ_type&
    ClaveProdServ () const;

    ClaveProdServ_type&
    ClaveProdServ ();

    void
    ClaveProdServ (const ClaveProdServ_type& x);

    void
    ClaveProdServ (::std::auto_ptr< ClaveProdServ_type > p);

    // NoIdentificacion
    //
    typedef ::XDSToXML::NoIdentificacion NoIdentificacion_type;
    typedef ::xsd::cxx::tree::optional< NoIdentificacion_type > NoIdentificacion_optional;
    typedef ::xsd::cxx::tree::traits< NoIdentificacion_type, char > NoIdentificacion_traits;

    const NoIdentificacion_optional&
    NoIdentificacion () const;

    NoIdentificacion_optional&
    NoIdentificacion ();

    void
    NoIdentificacion (const NoIdentificacion_type& x);

    void
    NoIdentificacion (const NoIdentificacion_optional& x);

    void
    NoIdentificacion (::std::auto_ptr< NoIdentificacion_type > p);

    // Cantidad
    //
    typedef ::XDSToXML::Cantidad Cantidad_type;
    typedef ::xsd::cxx::tree::traits< Cantidad_type, char > Cantidad_traits;

    const Cantidad_type&
    Cantidad () const;

    Cantidad_type&
    Cantidad ();

    void
    Cantidad (const Cantidad_type& x);

    void
    Cantidad (::std::auto_ptr< Cantidad_type > p);

    // ClaveUnidad
    //
    typedef ::sitio_internet::cfd::catalogos::c_ClaveUnidad ClaveUnidad_type;
    typedef ::xsd::cxx::tree::traits< ClaveUnidad_type, char > ClaveUnidad_traits;

    const ClaveUnidad_type&
    ClaveUnidad () const;

    ClaveUnidad_type&
    ClaveUnidad ();

    void
    ClaveUnidad (const ClaveUnidad_type& x);

    void
    ClaveUnidad (::std::auto_ptr< ClaveUnidad_type > p);

    // Unidad
    //
    typedef ::XDSToXML::Unidad Unidad_type;
    typedef ::xsd::cxx::tree::optional< Unidad_type > Unidad_optional;
    typedef ::xsd::cxx::tree::traits< Unidad_type, char > Unidad_traits;

    const Unidad_optional&
    Unidad () const;

    Unidad_optional&
    Unidad ();

    void
    Unidad (const Unidad_type& x);

    void
    Unidad (const Unidad_optional& x);

    void
    Unidad (::std::auto_ptr< Unidad_type > p);

    // Descripcion
    //
    typedef ::XDSToXML::Descripcion Descripcion_type;
    typedef ::xsd::cxx::tree::traits< Descripcion_type, char > Descripcion_traits;

    const Descripcion_type&
    Descripcion () const;

    Descripcion_type&
    Descripcion ();

    void
    Descripcion (const Descripcion_type& x);

    void
    Descripcion (::std::auto_ptr< Descripcion_type > p);

    // ValorUnitario
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe ValorUnitario_type;
    typedef ::xsd::cxx::tree::traits< ValorUnitario_type, char > ValorUnitario_traits;

    const ValorUnitario_type&
    ValorUnitario () const;

    ValorUnitario_type&
    ValorUnitario ();

    void
    ValorUnitario (const ValorUnitario_type& x);

    void
    ValorUnitario (::std::auto_ptr< ValorUnitario_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_type&
    Importe () const;

    Importe_type&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Descuento
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Descuento_type;
    typedef ::xsd::cxx::tree::optional< Descuento_type > Descuento_optional;
    typedef ::xsd::cxx::tree::traits< Descuento_type, char > Descuento_traits;

    const Descuento_optional&
    Descuento () const;

    Descuento_optional&
    Descuento ();

    void
    Descuento (const Descuento_type& x);

    void
    Descuento (const Descuento_optional& x);

    void
    Descuento (::std::auto_ptr< Descuento_type > p);

    // Constructors.
    //
    Concepto (const ClaveProdServ_type&,
              const Cantidad_type&,
              const ClaveUnidad_type&,
              const Descripcion_type&,
              const ValorUnitario_type&,
              const Importe_type&);

    Concepto (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Concepto (const Concepto& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Concepto*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Concepto&
    operator= (const Concepto& x);

    virtual 
    ~Concepto ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Impuestos_optional Impuestos_;
    InformacionAduanera_sequence InformacionAduanera_;
    CuentaPredial_optional CuentaPredial_;
    ComplementoConcepto_optional ComplementoConcepto_;
    Parte_sequence Parte_;
    ::xsd::cxx::tree::one< ClaveProdServ_type > ClaveProdServ_;
    NoIdentificacion_optional NoIdentificacion_;
    ::xsd::cxx::tree::one< Cantidad_type > Cantidad_;
    ::xsd::cxx::tree::one< ClaveUnidad_type > ClaveUnidad_;
    Unidad_optional Unidad_;
    ::xsd::cxx::tree::one< Descripcion_type > Descripcion_;
    ::xsd::cxx::tree::one< ValorUnitario_type > ValorUnitario_;
    ::xsd::cxx::tree::one< Importe_type > Importe_;
    Descuento_optional Descuento_;
  };

  class Retenciones: public ::xml_schema::type
  {
    public:
    // Retencion
    //
    typedef ::XDSToXML::Retencion Retencion_type;
    typedef ::xsd::cxx::tree::sequence< Retencion_type > Retencion_sequence;
    typedef Retencion_sequence::iterator Retencion_iterator;
    typedef Retencion_sequence::const_iterator Retencion_const_iterator;
    typedef ::xsd::cxx::tree::traits< Retencion_type, char > Retencion_traits;

    const Retencion_sequence&
    Retencion () const;

    Retencion_sequence&
    Retencion ();

    void
    Retencion (const Retencion_sequence& s);

    // Constructors.
    //
    Retenciones ();

    Retenciones (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Retenciones (const Retenciones& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual Retenciones*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Retenciones&
    operator= (const Retenciones& x);

    virtual 
    ~Retenciones ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Retencion_sequence Retencion_;
  };

  class Traslados: public ::xml_schema::type
  {
    public:
    // Traslado
    //
    typedef ::XDSToXML::Traslado Traslado_type;
    typedef ::xsd::cxx::tree::sequence< Traslado_type > Traslado_sequence;
    typedef Traslado_sequence::iterator Traslado_iterator;
    typedef Traslado_sequence::const_iterator Traslado_const_iterator;
    typedef ::xsd::cxx::tree::traits< Traslado_type, char > Traslado_traits;

    const Traslado_sequence&
    Traslado () const;

    Traslado_sequence&
    Traslado ();

    void
    Traslado (const Traslado_sequence& s);

    // Constructors.
    //
    Traslados ();

    Traslados (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Traslados (const Traslados& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Traslados*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Traslados&
    operator= (const Traslados& x);

    virtual 
    ~Traslados ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Traslado_sequence Traslado_;
  };

  class UUID: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    UUID ();

    UUID (const char*);

    UUID (const ::std::string&);

    UUID (const ::xml_schema::string&);

    UUID (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    UUID (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    UUID (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    UUID (const UUID& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual UUID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UUID ();
  };

  class Impuestos1: public ::xml_schema::type
  {
    public:
    // Traslados
    //
    typedef ::XDSToXML::Traslados1 Traslados_type;
    typedef ::xsd::cxx::tree::optional< Traslados_type > Traslados_optional;
    typedef ::xsd::cxx::tree::traits< Traslados_type, char > Traslados_traits;

    const Traslados_optional&
    Traslados () const;

    Traslados_optional&
    Traslados ();

    void
    Traslados (const Traslados_type& x);

    void
    Traslados (const Traslados_optional& x);

    void
    Traslados (::std::auto_ptr< Traslados_type > p);

    // Retenciones
    //
    typedef ::XDSToXML::Retenciones1 Retenciones_type;
    typedef ::xsd::cxx::tree::optional< Retenciones_type > Retenciones_optional;
    typedef ::xsd::cxx::tree::traits< Retenciones_type, char > Retenciones_traits;

    const Retenciones_optional&
    Retenciones () const;

    Retenciones_optional&
    Retenciones ();

    void
    Retenciones (const Retenciones_type& x);

    void
    Retenciones (const Retenciones_optional& x);

    void
    Retenciones (::std::auto_ptr< Retenciones_type > p);

    // Constructors.
    //
    Impuestos1 ();

    Impuestos1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Impuestos1 (const Impuestos1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Impuestos1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Impuestos1&
    operator= (const Impuestos1& x);

    virtual 
    ~Impuestos1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Traslados_optional Traslados_;
    Retenciones_optional Retenciones_;
  };

  class InformacionAduanera: public ::xml_schema::type
  {
    public:
    // NumeroPedimento
    //
    typedef ::XDSToXML::NumeroPedimento NumeroPedimento_type;
    typedef ::xsd::cxx::tree::traits< NumeroPedimento_type, char > NumeroPedimento_traits;

    const NumeroPedimento_type&
    NumeroPedimento () const;

    NumeroPedimento_type&
    NumeroPedimento ();

    void
    NumeroPedimento (const NumeroPedimento_type& x);

    void
    NumeroPedimento (::std::auto_ptr< NumeroPedimento_type > p);

    // Constructors.
    //
    InformacionAduanera (const NumeroPedimento_type&);

    InformacionAduanera (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    InformacionAduanera (const InformacionAduanera& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual InformacionAduanera*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InformacionAduanera&
    operator= (const InformacionAduanera& x);

    virtual 
    ~InformacionAduanera ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< NumeroPedimento_type > NumeroPedimento_;
  };

  class CuentaPredial: public ::xml_schema::type
  {
    public:
    // Numero
    //
    typedef ::XDSToXML::Numero Numero_type;
    typedef ::xsd::cxx::tree::traits< Numero_type, char > Numero_traits;

    const Numero_type&
    Numero () const;

    Numero_type&
    Numero ();

    void
    Numero (const Numero_type& x);

    void
    Numero (::std::auto_ptr< Numero_type > p);

    // Constructors.
    //
    CuentaPredial (const Numero_type&);

    CuentaPredial (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    CuentaPredial (const CuentaPredial& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual CuentaPredial*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CuentaPredial&
    operator= (const CuentaPredial& x);

    virtual 
    ~CuentaPredial ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Numero_type > Numero_;
  };

  class ComplementoConcepto: public ::xml_schema::type
  {
    public:
    // Constructors.
    //
    ComplementoConcepto ();

    ComplementoConcepto (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ComplementoConcepto (const ComplementoConcepto& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ComplementoConcepto*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ComplementoConcepto ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
  };

  class Parte: public ::xml_schema::type
  {
    public:
    // InformacionAduanera
    //
    typedef ::XDSToXML::InformacionAduanera1 InformacionAduanera_type;
    typedef ::xsd::cxx::tree::sequence< InformacionAduanera_type > InformacionAduanera_sequence;
    typedef InformacionAduanera_sequence::iterator InformacionAduanera_iterator;
    typedef InformacionAduanera_sequence::const_iterator InformacionAduanera_const_iterator;
    typedef ::xsd::cxx::tree::traits< InformacionAduanera_type, char > InformacionAduanera_traits;

    const InformacionAduanera_sequence&
    InformacionAduanera () const;

    InformacionAduanera_sequence&
    InformacionAduanera ();

    void
    InformacionAduanera (const InformacionAduanera_sequence& s);

    // ClaveProdServ
    //
    typedef ::sitio_internet::cfd::catalogos::c_ClaveProdServ ClaveProdServ_type;
    typedef ::xsd::cxx::tree::traits< ClaveProdServ_type, char > ClaveProdServ_traits;

    const ClaveProdServ_type&
    ClaveProdServ () const;

    ClaveProdServ_type&
    ClaveProdServ ();

    void
    ClaveProdServ (const ClaveProdServ_type& x);

    void
    ClaveProdServ (::std::auto_ptr< ClaveProdServ_type > p);

    // NoIdentificacion
    //
    typedef ::XDSToXML::NoIdentificacion NoIdentificacion_type;
    typedef ::xsd::cxx::tree::optional< NoIdentificacion_type > NoIdentificacion_optional;
    typedef ::xsd::cxx::tree::traits< NoIdentificacion_type, char > NoIdentificacion_traits;

    const NoIdentificacion_optional&
    NoIdentificacion () const;

    NoIdentificacion_optional&
    NoIdentificacion ();

    void
    NoIdentificacion (const NoIdentificacion_type& x);

    void
    NoIdentificacion (const NoIdentificacion_optional& x);

    void
    NoIdentificacion (::std::auto_ptr< NoIdentificacion_type > p);

    // Cantidad
    //
    typedef ::XDSToXML::Cantidad Cantidad_type;
    typedef ::xsd::cxx::tree::traits< Cantidad_type, char > Cantidad_traits;

    const Cantidad_type&
    Cantidad () const;

    Cantidad_type&
    Cantidad ();

    void
    Cantidad (const Cantidad_type& x);

    void
    Cantidad (::std::auto_ptr< Cantidad_type > p);

    // Unidad
    //
    typedef ::XDSToXML::Unidad Unidad_type;
    typedef ::xsd::cxx::tree::optional< Unidad_type > Unidad_optional;
    typedef ::xsd::cxx::tree::traits< Unidad_type, char > Unidad_traits;

    const Unidad_optional&
    Unidad () const;

    Unidad_optional&
    Unidad ();

    void
    Unidad (const Unidad_type& x);

    void
    Unidad (const Unidad_optional& x);

    void
    Unidad (::std::auto_ptr< Unidad_type > p);

    // Descripcion
    //
    typedef ::XDSToXML::Descripcion Descripcion_type;
    typedef ::xsd::cxx::tree::traits< Descripcion_type, char > Descripcion_traits;

    const Descripcion_type&
    Descripcion () const;

    Descripcion_type&
    Descripcion ();

    void
    Descripcion (const Descripcion_type& x);

    void
    Descripcion (::std::auto_ptr< Descripcion_type > p);

    // ValorUnitario
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe ValorUnitario_type;
    typedef ::xsd::cxx::tree::optional< ValorUnitario_type > ValorUnitario_optional;
    typedef ::xsd::cxx::tree::traits< ValorUnitario_type, char > ValorUnitario_traits;

    const ValorUnitario_optional&
    ValorUnitario () const;

    ValorUnitario_optional&
    ValorUnitario ();

    void
    ValorUnitario (const ValorUnitario_type& x);

    void
    ValorUnitario (const ValorUnitario_optional& x);

    void
    ValorUnitario (::std::auto_ptr< ValorUnitario_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::optional< Importe_type > Importe_optional;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_optional&
    Importe () const;

    Importe_optional&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (const Importe_optional& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Constructors.
    //
    Parte (const ClaveProdServ_type&,
           const Cantidad_type&,
           const Descripcion_type&);

    Parte (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Parte (const Parte& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Parte*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Parte&
    operator= (const Parte& x);

    virtual 
    ~Parte ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    InformacionAduanera_sequence InformacionAduanera_;
    ::xsd::cxx::tree::one< ClaveProdServ_type > ClaveProdServ_;
    NoIdentificacion_optional NoIdentificacion_;
    ::xsd::cxx::tree::one< Cantidad_type > Cantidad_;
    Unidad_optional Unidad_;
    ::xsd::cxx::tree::one< Descripcion_type > Descripcion_;
    ValorUnitario_optional ValorUnitario_;
    Importe_optional Importe_;
  };

  class NoIdentificacion: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    NoIdentificacion ();

    NoIdentificacion (const char*);

    NoIdentificacion (const ::std::string&);

    NoIdentificacion (const ::xml_schema::string&);

    NoIdentificacion (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NoIdentificacion (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NoIdentificacion (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    NoIdentificacion (const NoIdentificacion& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual NoIdentificacion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~NoIdentificacion ();
  };

  class Cantidad: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    Cantidad (const ::xml_schema::decimal&);

    Cantidad (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Cantidad (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Cantidad (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Cantidad (const Cantidad& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Cantidad*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Cantidad ();
  };

  class Unidad: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Unidad ();

    Unidad (const char*);

    Unidad (const ::std::string&);

    Unidad (const ::xml_schema::string&);

    Unidad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Unidad (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Unidad (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Unidad (const Unidad& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Unidad*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Unidad ();
  };

  class Descripcion: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Descripcion ();

    Descripcion (const char*);

    Descripcion (const ::std::string&);

    Descripcion (const ::xml_schema::string&);

    Descripcion (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Descripcion (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Descripcion (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    Descripcion (const Descripcion& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual Descripcion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Descripcion ();
  };

  class Retencion: public ::xml_schema::type
  {
    public:
    // Impuesto
    //
    typedef ::sitio_internet::cfd::catalogos::c_Impuesto Impuesto_type;
    typedef ::xsd::cxx::tree::traits< Impuesto_type, char > Impuesto_traits;

    const Impuesto_type&
    Impuesto () const;

    Impuesto_type&
    Impuesto ();

    void
    Impuesto (const Impuesto_type& x);

    void
    Impuesto (::std::auto_ptr< Impuesto_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_type&
    Importe () const;

    Importe_type&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Constructors.
    //
    Retencion (const Impuesto_type&,
               const Importe_type&);

    Retencion (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Retencion (const Retencion& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Retencion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Retencion&
    operator= (const Retencion& x);

    virtual 
    ~Retencion ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Impuesto_type > Impuesto_;
    ::xsd::cxx::tree::one< Importe_type > Importe_;
  };

  class Traslado: public ::xml_schema::type
  {
    public:
    // Impuesto
    //
    typedef ::sitio_internet::cfd::catalogos::c_Impuesto Impuesto_type;
    typedef ::xsd::cxx::tree::traits< Impuesto_type, char > Impuesto_traits;

    const Impuesto_type&
    Impuesto () const;

    Impuesto_type&
    Impuesto ();

    void
    Impuesto (const Impuesto_type& x);

    void
    Impuesto (::std::auto_ptr< Impuesto_type > p);

    // TipoFactor
    //
    typedef ::sitio_internet::cfd::catalogos::c_TipoFactor TipoFactor_type;
    typedef ::xsd::cxx::tree::traits< TipoFactor_type, char > TipoFactor_traits;

    const TipoFactor_type&
    TipoFactor () const;

    TipoFactor_type&
    TipoFactor ();

    void
    TipoFactor (const TipoFactor_type& x);

    void
    TipoFactor (::std::auto_ptr< TipoFactor_type > p);

    // TasaOCuota
    //
    typedef ::XDSToXML::TasaOCuota TasaOCuota_type;
    typedef ::xsd::cxx::tree::traits< TasaOCuota_type, char > TasaOCuota_traits;

    const TasaOCuota_type&
    TasaOCuota () const;

    TasaOCuota_type&
    TasaOCuota ();

    void
    TasaOCuota (const TasaOCuota_type& x);

    void
    TasaOCuota (::std::auto_ptr< TasaOCuota_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_type&
    Importe () const;

    Importe_type&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Constructors.
    //
    Traslado (const Impuesto_type&,
              const TipoFactor_type&,
              const TasaOCuota_type&,
              const Importe_type&);

    Traslado (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    Traslado (const Traslado& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual Traslado*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Traslado&
    operator= (const Traslado& x);

    virtual 
    ~Traslado ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Impuesto_type > Impuesto_;
    ::xsd::cxx::tree::one< TipoFactor_type > TipoFactor_;
    ::xsd::cxx::tree::one< TasaOCuota_type > TasaOCuota_;
    ::xsd::cxx::tree::one< Importe_type > Importe_;
  };

  class Traslados1: public ::xml_schema::type
  {
    public:
    // Traslado
    //
    typedef ::XDSToXML::Traslado1 Traslado_type;
    typedef ::xsd::cxx::tree::sequence< Traslado_type > Traslado_sequence;
    typedef Traslado_sequence::iterator Traslado_iterator;
    typedef Traslado_sequence::const_iterator Traslado_const_iterator;
    typedef ::xsd::cxx::tree::traits< Traslado_type, char > Traslado_traits;

    const Traslado_sequence&
    Traslado () const;

    Traslado_sequence&
    Traslado ();

    void
    Traslado (const Traslado_sequence& s);

    // Constructors.
    //
    Traslados1 ();

    Traslados1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Traslados1 (const Traslados1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Traslados1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Traslados1&
    operator= (const Traslados1& x);

    virtual 
    ~Traslados1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Traslado_sequence Traslado_;
  };

  class Retenciones1: public ::xml_schema::type
  {
    public:
    // Retencion
    //
    typedef ::XDSToXML::Retencion1 Retencion_type;
    typedef ::xsd::cxx::tree::sequence< Retencion_type > Retencion_sequence;
    typedef Retencion_sequence::iterator Retencion_iterator;
    typedef Retencion_sequence::const_iterator Retencion_const_iterator;
    typedef ::xsd::cxx::tree::traits< Retencion_type, char > Retencion_traits;

    const Retencion_sequence&
    Retencion () const;

    Retencion_sequence&
    Retencion ();

    void
    Retencion (const Retencion_sequence& s);

    // Constructors.
    //
    Retenciones1 ();

    Retenciones1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Retenciones1 (const Retenciones1& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual Retenciones1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Retenciones1&
    operator= (const Retenciones1& x);

    virtual 
    ~Retenciones1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Retencion_sequence Retencion_;
  };

  class NumeroPedimento: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    NumeroPedimento ();

    NumeroPedimento (const char*);

    NumeroPedimento (const ::std::string&);

    NumeroPedimento (const ::xml_schema::string&);

    NumeroPedimento (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    NumeroPedimento (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    NumeroPedimento (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    NumeroPedimento (const NumeroPedimento& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual NumeroPedimento*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~NumeroPedimento ();
  };

  class Numero: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Numero ();

    Numero (const char*);

    Numero (const ::std::string&);

    Numero (const ::xml_schema::string&);

    Numero (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Numero (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Numero (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Numero (const Numero& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Numero*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Numero ();
  };

  class InformacionAduanera1: public ::xml_schema::type
  {
    public:
    // NumeroPedimento
    //
    typedef ::XDSToXML::NumeroPedimento NumeroPedimento_type;
    typedef ::xsd::cxx::tree::traits< NumeroPedimento_type, char > NumeroPedimento_traits;

    const NumeroPedimento_type&
    NumeroPedimento () const;

    NumeroPedimento_type&
    NumeroPedimento ();

    void
    NumeroPedimento (const NumeroPedimento_type& x);

    void
    NumeroPedimento (::std::auto_ptr< NumeroPedimento_type > p);

    // Constructors.
    //
    InformacionAduanera1 (const NumeroPedimento_type&);

    InformacionAduanera1 (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    InformacionAduanera1 (const InformacionAduanera1& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual InformacionAduanera1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    InformacionAduanera1&
    operator= (const InformacionAduanera1& x);

    virtual 
    ~InformacionAduanera1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< NumeroPedimento_type > NumeroPedimento_;
  };

  class TasaOCuota: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    TasaOCuota (const ::xml_schema::decimal&);

    TasaOCuota (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TasaOCuota (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TasaOCuota (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    TasaOCuota (const TasaOCuota& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual TasaOCuota*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TasaOCuota ();
  };

  class Traslado1: public ::xml_schema::type
  {
    public:
    // Base
    //
    typedef ::XDSToXML::Base Base_type;
    typedef ::xsd::cxx::tree::traits< Base_type, char > Base_traits;

    const Base_type&
    Base () const;

    Base_type&
    Base ();

    void
    Base (const Base_type& x);

    void
    Base (::std::auto_ptr< Base_type > p);

    // Impuesto
    //
    typedef ::sitio_internet::cfd::catalogos::c_Impuesto Impuesto_type;
    typedef ::xsd::cxx::tree::traits< Impuesto_type, char > Impuesto_traits;

    const Impuesto_type&
    Impuesto () const;

    Impuesto_type&
    Impuesto ();

    void
    Impuesto (const Impuesto_type& x);

    void
    Impuesto (::std::auto_ptr< Impuesto_type > p);

    // TipoFactor
    //
    typedef ::sitio_internet::cfd::catalogos::c_TipoFactor TipoFactor_type;
    typedef ::xsd::cxx::tree::traits< TipoFactor_type, char > TipoFactor_traits;

    const TipoFactor_type&
    TipoFactor () const;

    TipoFactor_type&
    TipoFactor ();

    void
    TipoFactor (const TipoFactor_type& x);

    void
    TipoFactor (::std::auto_ptr< TipoFactor_type > p);

    // TasaOCuota
    //
    typedef ::XDSToXML::TasaOCuota TasaOCuota_type;
    typedef ::xsd::cxx::tree::optional< TasaOCuota_type > TasaOCuota_optional;
    typedef ::xsd::cxx::tree::traits< TasaOCuota_type, char > TasaOCuota_traits;

    const TasaOCuota_optional&
    TasaOCuota () const;

    TasaOCuota_optional&
    TasaOCuota ();

    void
    TasaOCuota (const TasaOCuota_type& x);

    void
    TasaOCuota (const TasaOCuota_optional& x);

    void
    TasaOCuota (::std::auto_ptr< TasaOCuota_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::optional< Importe_type > Importe_optional;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_optional&
    Importe () const;

    Importe_optional&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (const Importe_optional& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Constructors.
    //
    Traslado1 (const Base_type&,
               const Impuesto_type&,
               const TipoFactor_type&);

    Traslado1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Traslado1 (const Traslado1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Traslado1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Traslado1&
    operator= (const Traslado1& x);

    virtual 
    ~Traslado1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Base_type > Base_;
    ::xsd::cxx::tree::one< Impuesto_type > Impuesto_;
    ::xsd::cxx::tree::one< TipoFactor_type > TipoFactor_;
    TasaOCuota_optional TasaOCuota_;
    Importe_optional Importe_;
  };

  class Retencion1: public ::xml_schema::type
  {
    public:
    // Base
    //
    typedef ::XDSToXML::Base Base_type;
    typedef ::xsd::cxx::tree::traits< Base_type, char > Base_traits;

    const Base_type&
    Base () const;

    Base_type&
    Base ();

    void
    Base (const Base_type& x);

    void
    Base (::std::auto_ptr< Base_type > p);

    // Impuesto
    //
    typedef ::sitio_internet::cfd::catalogos::c_Impuesto Impuesto_type;
    typedef ::xsd::cxx::tree::traits< Impuesto_type, char > Impuesto_traits;

    const Impuesto_type&
    Impuesto () const;

    Impuesto_type&
    Impuesto ();

    void
    Impuesto (const Impuesto_type& x);

    void
    Impuesto (::std::auto_ptr< Impuesto_type > p);

    // TipoFactor
    //
    typedef ::sitio_internet::cfd::catalogos::c_TipoFactor TipoFactor_type;
    typedef ::xsd::cxx::tree::traits< TipoFactor_type, char > TipoFactor_traits;

    const TipoFactor_type&
    TipoFactor () const;

    TipoFactor_type&
    TipoFactor ();

    void
    TipoFactor (const TipoFactor_type& x);

    void
    TipoFactor (::std::auto_ptr< TipoFactor_type > p);

    // TasaOCuota
    //
    typedef ::XDSToXML::TasaOCuota TasaOCuota_type;
    typedef ::xsd::cxx::tree::traits< TasaOCuota_type, char > TasaOCuota_traits;

    const TasaOCuota_type&
    TasaOCuota () const;

    TasaOCuota_type&
    TasaOCuota ();

    void
    TasaOCuota (const TasaOCuota_type& x);

    void
    TasaOCuota (::std::auto_ptr< TasaOCuota_type > p);

    // Importe
    //
    typedef ::sitio_internet::cfd::tipoDatos::tdCFDI::t_Importe Importe_type;
    typedef ::xsd::cxx::tree::traits< Importe_type, char > Importe_traits;

    const Importe_type&
    Importe () const;

    Importe_type&
    Importe ();

    void
    Importe (const Importe_type& x);

    void
    Importe (::std::auto_ptr< Importe_type > p);

    // Constructors.
    //
    Retencion1 (const Base_type&,
                const Impuesto_type&,
                const TipoFactor_type&,
                const TasaOCuota_type&,
                const Importe_type&);

    Retencion1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    Retencion1 (const Retencion1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual Retencion1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Retencion1&
    operator= (const Retencion1& x);

    virtual 
    ~Retencion1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Base_type > Base_;
    ::xsd::cxx::tree::one< Impuesto_type > Impuesto_;
    ::xsd::cxx::tree::one< TipoFactor_type > TipoFactor_;
    ::xsd::cxx::tree::one< TasaOCuota_type > TasaOCuota_;
    ::xsd::cxx::tree::one< Importe_type > Importe_;
  };

  class Base: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    Base (const ::xml_schema::decimal&);

    Base (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Base (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Base (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Base (const Base& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Base*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Base ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace XDSToXML
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& uri,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& uri,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& uri,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& id,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& is,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& is,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CFDV33_HXX
