// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>
#include <iostream>

#include "cfdv33.hpp"

namespace XDSToXML
{
  
  const Comprobante::CfdiRelacionados_optional& Comprobante::
  CfdiRelacionados () const
  {
    return this->CfdiRelacionados_;
  }

  Comprobante::CfdiRelacionados_optional& Comprobante::
  CfdiRelacionados ()
  {
    return this->CfdiRelacionados_;
  }

  void Comprobante::
  CfdiRelacionados (const CfdiRelacionados_type& x)
  {
    this->CfdiRelacionados_.set (x);
  }

  void Comprobante::
  CfdiRelacionados (const CfdiRelacionados_optional& x)
  {
    this->CfdiRelacionados_ = x;
  }

  void Comprobante::
  CfdiRelacionados (::std::auto_ptr< CfdiRelacionados_type > x)
  {
    this->CfdiRelacionados_.set (x);
  }

  const Comprobante::Emisor_type& Comprobante::
  Emisor () const
  {
    return this->Emisor_.get ();
  }

  Comprobante::Emisor_type& Comprobante::
  Emisor ()
  {
    return this->Emisor_.get ();
  }

  void Comprobante::
  Emisor (const Emisor_type& x)
  {
    this->Emisor_.set (x);
  }

  void Comprobante::
  Emisor (::std::auto_ptr< Emisor_type > x)
  {
    this->Emisor_.set (x);
  }

  const Comprobante::Receptor_type& Comprobante::
  Receptor () const
  {
    return this->Receptor_.get ();
  }

  Comprobante::Receptor_type& Comprobante::
  Receptor ()
  {
    return this->Receptor_.get ();
  }

  void Comprobante::
  Receptor (const Receptor_type& x)
  {
    this->Receptor_.set (x);
  }

  void Comprobante::
  Receptor (::std::auto_ptr< Receptor_type > x)
  {
    this->Receptor_.set (x);
  }

  const Comprobante::Conceptos_type& Comprobante::
  Conceptos () const
  {
    return this->Conceptos_.get ();
  }

  Comprobante::Conceptos_type& Comprobante::
  Conceptos ()
  {
    return this->Conceptos_.get ();
  }

  void Comprobante::
  Conceptos (const Conceptos_type& x)
  {
    this->Conceptos_.set (x);
  }

  void Comprobante::
  Conceptos (::std::auto_ptr< Conceptos_type > x)
  {
    this->Conceptos_.set (x);
  }

  const Comprobante::Impuestos_optional& Comprobante::
  Impuestos () const
  {
    return this->Impuestos_;
  }

  Comprobante::Impuestos_optional& Comprobante::
  Impuestos ()
  {
    return this->Impuestos_;
  }

  void Comprobante::
  Impuestos (const Impuestos_type& x)
  {
    this->Impuestos_.set (x);
  }

  void Comprobante::
  Impuestos (const Impuestos_optional& x)
  {
    this->Impuestos_ = x;
  }

  void Comprobante::
  Impuestos (::std::auto_ptr< Impuestos_type > x)
  {
    this->Impuestos_.set (x);
  }

  const Comprobante::Complemento_sequence& Comprobante::
  Complemento () const
  {
    return this->Complemento_;
  }

  Comprobante::Complemento_sequence& Comprobante::
  Complemento ()
  {
    return this->Complemento_;
  }

  void Comprobante::
  Complemento (const Complemento_sequence& s)
  {
    this->Complemento_ = s;
  }

  const Comprobante::Addenda_optional& Comprobante::
  Addenda () const
  {
    return this->Addenda_;
  }

  Comprobante::Addenda_optional& Comprobante::
  Addenda ()
  {
    return this->Addenda_;
  }

  void Comprobante::
  Addenda (const Addenda_type& x)
  {
    this->Addenda_.set (x);
  }

  void Comprobante::
  Addenda (const Addenda_optional& x)
  {
    this->Addenda_ = x;
  }

  void Comprobante::
  Addenda (::std::auto_ptr< Addenda_type > x)
  {
    this->Addenda_.set (x);
  }

  const Comprobante::Version_type& Comprobante::
  Version () const
  {
    return this->Version_.get ();
  }

  const Comprobante::Version_type& Comprobante::
  Version_default_value ()
  {
    return Version_default_value_;
  }

  const Comprobante::Serie_optional& Comprobante::
  Serie () const
  {
    return this->Serie_;
  }

  Comprobante::Serie_optional& Comprobante::
  Serie ()
  {
    return this->Serie_;
  }

  void Comprobante::
  Serie (const Serie_type& x)
  {
    this->Serie_.set (x);
  }

  void Comprobante::
  Serie (const Serie_optional& x)
  {
    this->Serie_ = x;
  }

  void Comprobante::
  Serie (::std::auto_ptr< Serie_type > x)
  {
    this->Serie_.set (x);
  }

  const Comprobante::Folio_optional& Comprobante::
  Folio () const
  {
    return this->Folio_;
  }

  Comprobante::Folio_optional& Comprobante::
  Folio ()
  {
    return this->Folio_;
  }

  void Comprobante::
  Folio (const Folio_type& x)
  {
    this->Folio_.set (x);
  }

  void Comprobante::
  Folio (const Folio_optional& x)
  {
    this->Folio_ = x;
  }

  void Comprobante::
  Folio (::std::auto_ptr< Folio_type > x)
  {
    this->Folio_.set (x);
  }

  const Comprobante::Fecha_type& Comprobante::
  Fecha () const
  {
    return this->Fecha_.get ();
  }

  Comprobante::Fecha_type& Comprobante::
  Fecha ()
  {
    return this->Fecha_.get ();
  }

  void Comprobante::
  Fecha (const Fecha_type& x)
  {
    this->Fecha_.set (x);
  }

  void Comprobante::
  Fecha (::std::auto_ptr< Fecha_type > x)
  {
    this->Fecha_.set (x);
  }

  const Comprobante::Sello_type& Comprobante::
  Sello () const
  {
    return this->Sello_.get ();
  }

  Comprobante::Sello_type& Comprobante::
  Sello ()
  {
    return this->Sello_.get ();
  }

  void Comprobante::
  Sello (const Sello_type& x)
  {
    this->Sello_.set (x);
  }

  void Comprobante::
  Sello (::std::auto_ptr< Sello_type > x)
  {
    this->Sello_.set (x);
  }

  const Comprobante::FormaPago_optional& Comprobante::
  FormaPago () const
  {
    return this->FormaPago_;
  }

  Comprobante::FormaPago_optional& Comprobante::
  FormaPago ()
  {
    return this->FormaPago_;
  }

  void Comprobante::
  FormaPago (const FormaPago_type& x)
  {
    this->FormaPago_.set (x);
  }

  void Comprobante::
  FormaPago (const FormaPago_optional& x)
  {
    this->FormaPago_ = x;
  }

  void Comprobante::
  FormaPago (::std::auto_ptr< FormaPago_type > x)
  {
    this->FormaPago_.set (x);
  }

  const Comprobante::NoCertificado_type& Comprobante::
  NoCertificado () const
  {
    return this->NoCertificado_.get ();
  }

  Comprobante::NoCertificado_type& Comprobante::
  NoCertificado ()
  {
    return this->NoCertificado_.get ();
  }

  void Comprobante::
  NoCertificado (const NoCertificado_type& x)
  {
    this->NoCertificado_.set (x);
  }

  void Comprobante::
  NoCertificado (::std::auto_ptr< NoCertificado_type > x)
  {
    this->NoCertificado_.set (x);
  }

  const Comprobante::Certificado_type& Comprobante::
  Certificado () const
  {
    return this->Certificado_.get ();
  }

  Comprobante::Certificado_type& Comprobante::
  Certificado ()
  {
    return this->Certificado_.get ();
  }

  void Comprobante::
  Certificado (const Certificado_type& x)
  {
    this->Certificado_.set (x);
  }

  void Comprobante::
  Certificado (::std::auto_ptr< Certificado_type > x)
  {
    this->Certificado_.set (x);
  }

  const Comprobante::CondicionesDePago_optional& Comprobante::
  CondicionesDePago () const
  {
    return this->CondicionesDePago_;
  }

  Comprobante::CondicionesDePago_optional& Comprobante::
  CondicionesDePago ()
  {
    return this->CondicionesDePago_;
  }

  void Comprobante::
  CondicionesDePago (const CondicionesDePago_type& x)
  {
    this->CondicionesDePago_.set (x);
  }

  void Comprobante::
  CondicionesDePago (const CondicionesDePago_optional& x)
  {
    this->CondicionesDePago_ = x;
  }

  void Comprobante::
  CondicionesDePago (::std::auto_ptr< CondicionesDePago_type > x)
  {
    this->CondicionesDePago_.set (x);
  }

  const Comprobante::SubTotal_type& Comprobante::
  SubTotal () const
  {
    return this->SubTotal_.get ();
  }

  Comprobante::SubTotal_type& Comprobante::
  SubTotal ()
  {
    return this->SubTotal_.get ();
  }

  void Comprobante::
  SubTotal (const SubTotal_type& x)
  {
    this->SubTotal_.set (x);
  }

  void Comprobante::
  SubTotal (::std::auto_ptr< SubTotal_type > x)
  {
    this->SubTotal_.set (x);
  }

  const Comprobante::Descuento_optional& Comprobante::
  Descuento () const
  {
    return this->Descuento_;
  }

  Comprobante::Descuento_optional& Comprobante::
  Descuento ()
  {
    return this->Descuento_;
  }

  void Comprobante::
  Descuento (const Descuento_type& x)
  {
    this->Descuento_.set (x);
  }

  void Comprobante::
  Descuento (const Descuento_optional& x)
  {
    this->Descuento_ = x;
  }

  void Comprobante::
  Descuento (::std::auto_ptr< Descuento_type > x)
  {
    this->Descuento_.set (x);
  }

  const Comprobante::Moneda_type& Comprobante::
  Moneda () const
  {
    return this->Moneda_.get ();
  }

  Comprobante::Moneda_type& Comprobante::
  Moneda ()
  {
    return this->Moneda_.get ();
  }

  void Comprobante::
  Moneda (const Moneda_type& x)
  {
    this->Moneda_.set (x);
  }

  void Comprobante::
  Moneda (::std::auto_ptr< Moneda_type > x)
  {
    this->Moneda_.set (x);
  }

  const Comprobante::TipoCambio_optional& Comprobante::
  TipoCambio () const
  {
    return this->TipoCambio_;
  }

  Comprobante::TipoCambio_optional& Comprobante::
  TipoCambio ()
  {
    return this->TipoCambio_;
  }

  void Comprobante::
  TipoCambio (const TipoCambio_type& x)
  {
    this->TipoCambio_.set (x);
  }

  void Comprobante::
  TipoCambio (const TipoCambio_optional& x)
  {
    this->TipoCambio_ = x;
  }

  void Comprobante::
  TipoCambio (::std::auto_ptr< TipoCambio_type > x)
  {
    this->TipoCambio_.set (x);
  }

  const Comprobante::Total_type& Comprobante::
  Total () const
  {
    return this->Total_.get ();
  }

  Comprobante::Total_type& Comprobante::
  Total ()
  {
    return this->Total_.get ();
  }

  void Comprobante::
  Total (const Total_type& x)
  {
    this->Total_.set (x);
  }

  void Comprobante::
  Total (::std::auto_ptr< Total_type > x)
  {
    this->Total_.set (x);
  }

  const Comprobante::TipoDeComprobante_type& Comprobante::
  TipoDeComprobante () const
  {
    return this->TipoDeComprobante_.get ();
  }

  Comprobante::TipoDeComprobante_type& Comprobante::
  TipoDeComprobante ()
  {
    return this->TipoDeComprobante_.get ();
  }

  void Comprobante::
  TipoDeComprobante (const TipoDeComprobante_type& x)
  {
    this->TipoDeComprobante_.set (x);
  }

  void Comprobante::
  TipoDeComprobante (::std::auto_ptr< TipoDeComprobante_type > x)
  {
    this->TipoDeComprobante_.set (x);
  }

  const Comprobante::MetodoPago_optional& Comprobante::
  MetodoPago () const
  {
    return this->MetodoPago_;
  }

  Comprobante::MetodoPago_optional& Comprobante::
  MetodoPago ()
  {
    return this->MetodoPago_;
  }

  void Comprobante::
  MetodoPago (const MetodoPago_type& x)
  {
    this->MetodoPago_.set (x);
  }

  void Comprobante::
  MetodoPago (const MetodoPago_optional& x)
  {
    this->MetodoPago_ = x;
  }

  void Comprobante::
  MetodoPago (::std::auto_ptr< MetodoPago_type > x)
  {
    this->MetodoPago_.set (x);
  }

  const Comprobante::LugarExpedicion_type& Comprobante::
  LugarExpedicion () const
  {
    return this->LugarExpedicion_.get ();
  }

  Comprobante::LugarExpedicion_type& Comprobante::
  LugarExpedicion ()
  {
    return this->LugarExpedicion_.get ();
  }

  void Comprobante::
  LugarExpedicion (const LugarExpedicion_type& x)
  {
    this->LugarExpedicion_.set (x);
  }

  void Comprobante::
  LugarExpedicion (::std::auto_ptr< LugarExpedicion_type > x)
  {
    this->LugarExpedicion_.set (x);
  }

  const Comprobante::Confirmacion_optional& Comprobante::
  Confirmacion () const
  {
    return this->Confirmacion_;
  }

  Comprobante::Confirmacion_optional& Comprobante::
  Confirmacion ()
  {
    return this->Confirmacion_;
  }

  void Comprobante::
  Confirmacion (const Confirmacion_type& x)
  {
    this->Confirmacion_.set (x);
  }

  void Comprobante::
  Confirmacion (const Confirmacion_optional& x)
  {
    this->Confirmacion_ = x;
  }

  void Comprobante::
  Confirmacion (::std::auto_ptr< Confirmacion_type > x)
  {
    this->Confirmacion_.set (x);
  }


  // CfdiRelacionados
  // 

  const CfdiRelacionados::CfdiRelacionado_sequence& CfdiRelacionados::
  CfdiRelacionado () const
  {
    return this->CfdiRelacionado_;
  }

  CfdiRelacionados::CfdiRelacionado_sequence& CfdiRelacionados::
  CfdiRelacionado ()
  {
    return this->CfdiRelacionado_;
  }

  void CfdiRelacionados::
  CfdiRelacionado (const CfdiRelacionado_sequence& s)
  {
    this->CfdiRelacionado_ = s;
  }

  const CfdiRelacionados::TipoRelacion_type& CfdiRelacionados::
  TipoRelacion () const
  {
    return this->TipoRelacion_.get ();
  }

  CfdiRelacionados::TipoRelacion_type& CfdiRelacionados::
  TipoRelacion ()
  {
    return this->TipoRelacion_.get ();
  }

  void CfdiRelacionados::
  TipoRelacion (const TipoRelacion_type& x)
  {
    this->TipoRelacion_.set (x);
  }

  void CfdiRelacionados::
  TipoRelacion (::std::auto_ptr< TipoRelacion_type > x)
  {
    this->TipoRelacion_.set (x);
  }


  // Emisor
  // 

  const Emisor::Rfc_type& Emisor::
  Rfc () const
  {
    return this->Rfc_.get ();
  }

  Emisor::Rfc_type& Emisor::
  Rfc ()
  {
    return this->Rfc_.get ();
  }

  void Emisor::
  Rfc (const Rfc_type& x)
  {
    this->Rfc_.set (x);
  }

  void Emisor::
  Rfc (::std::auto_ptr< Rfc_type > x)
  {
    this->Rfc_.set (x);
  }

  const Emisor::Nombre_optional& Emisor::
  Nombre () const
  {
    return this->Nombre_;
  }

  Emisor::Nombre_optional& Emisor::
  Nombre ()
  {
    return this->Nombre_;
  }

  void Emisor::
  Nombre (const Nombre_type& x)
  {
    this->Nombre_.set (x);
  }

  void Emisor::
  Nombre (const Nombre_optional& x)
  {
    this->Nombre_ = x;
  }

  void Emisor::
  Nombre (::std::auto_ptr< Nombre_type > x)
  {
    this->Nombre_.set (x);
  }

  const Emisor::RegimenFiscal_type& Emisor::
  RegimenFiscal () const
  {
    return this->RegimenFiscal_.get ();
  }

  Emisor::RegimenFiscal_type& Emisor::
  RegimenFiscal ()
  {
    return this->RegimenFiscal_.get ();
  }

  void Emisor::
  RegimenFiscal (const RegimenFiscal_type& x)
  {
    this->RegimenFiscal_.set (x);
  }

  void Emisor::
  RegimenFiscal (::std::auto_ptr< RegimenFiscal_type > x)
  {
    this->RegimenFiscal_.set (x);
  }


  // Receptor
  // 

  const Receptor::Rfc_type& Receptor::
  Rfc () const
  {
    return this->Rfc_.get ();
  }

  Receptor::Rfc_type& Receptor::
  Rfc ()
  {
    return this->Rfc_.get ();
  }

  void Receptor::
  Rfc (const Rfc_type& x)
  {
    this->Rfc_.set (x);
  }

  void Receptor::
  Rfc (::std::auto_ptr< Rfc_type > x)
  {
    this->Rfc_.set (x);
  }

  const Receptor::Nombre_optional& Receptor::
  Nombre () const
  {
    return this->Nombre_;
  }

  Receptor::Nombre_optional& Receptor::
  Nombre ()
  {
    return this->Nombre_;
  }

  void Receptor::
  Nombre (const Nombre_type& x)
  {
    this->Nombre_.set (x);
  }

  void Receptor::
  Nombre (const Nombre_optional& x)
  {
    this->Nombre_ = x;
  }

  void Receptor::
  Nombre (::std::auto_ptr< Nombre_type > x)
  {
    this->Nombre_.set (x);
  }

  const Receptor::ResidenciaFiscal_optional& Receptor::
  ResidenciaFiscal () const
  {
    return this->ResidenciaFiscal_;
  }

  Receptor::ResidenciaFiscal_optional& Receptor::
  ResidenciaFiscal ()
  {
    return this->ResidenciaFiscal_;
  }

  void Receptor::
  ResidenciaFiscal (const ResidenciaFiscal_type& x)
  {
    this->ResidenciaFiscal_.set (x);
  }

  void Receptor::
  ResidenciaFiscal (const ResidenciaFiscal_optional& x)
  {
    this->ResidenciaFiscal_ = x;
  }

  void Receptor::
  ResidenciaFiscal (::std::auto_ptr< ResidenciaFiscal_type > x)
  {
    this->ResidenciaFiscal_.set (x);
  }

  const Receptor::NumRegIdTrib_optional& Receptor::
  NumRegIdTrib () const
  {
    return this->NumRegIdTrib_;
  }

  Receptor::NumRegIdTrib_optional& Receptor::
  NumRegIdTrib ()
  {
    return this->NumRegIdTrib_;
  }

  void Receptor::
  NumRegIdTrib (const NumRegIdTrib_type& x)
  {
    this->NumRegIdTrib_.set (x);
  }

  void Receptor::
  NumRegIdTrib (const NumRegIdTrib_optional& x)
  {
    this->NumRegIdTrib_ = x;
  }

  void Receptor::
  NumRegIdTrib (::std::auto_ptr< NumRegIdTrib_type > x)
  {
    this->NumRegIdTrib_.set (x);
  }

  const Receptor::UsoCFDI_type& Receptor::
  UsoCFDI () const
  {
    return this->UsoCFDI_.get ();
  }

  Receptor::UsoCFDI_type& Receptor::
  UsoCFDI ()
  {
    return this->UsoCFDI_.get ();
  }

  void Receptor::
  UsoCFDI (const UsoCFDI_type& x)
  {
    this->UsoCFDI_.set (x);
  }

  void Receptor::
  UsoCFDI (::std::auto_ptr< UsoCFDI_type > x)
  {
    this->UsoCFDI_.set (x);
  }


  // Conceptos
  // 

  const Conceptos::Concepto_sequence& Conceptos::
  Concepto () const
  {
    return this->Concepto_;
  }

  Conceptos::Concepto_sequence& Conceptos::
  Concepto ()
  {
    return this->Concepto_;
  }

  void Conceptos::
  Concepto (const Concepto_sequence& s)
  {
    this->Concepto_ = s;
  }


  // Impuestos
  // 

  const Impuestos::Retenciones_optional& Impuestos::
  Retenciones () const
  {
    return this->Retenciones_;
  }

  Impuestos::Retenciones_optional& Impuestos::
  Retenciones ()
  {
    return this->Retenciones_;
  }

  void Impuestos::
  Retenciones (const Retenciones_type& x)
  {
    this->Retenciones_.set (x);
  }

  void Impuestos::
  Retenciones (const Retenciones_optional& x)
  {
    this->Retenciones_ = x;
  }

  void Impuestos::
  Retenciones (::std::auto_ptr< Retenciones_type > x)
  {
    this->Retenciones_.set (x);
  }

  const Impuestos::Traslados_optional& Impuestos::
  Traslados () const
  {
    return this->Traslados_;
  }

  Impuestos::Traslados_optional& Impuestos::
  Traslados ()
  {
    return this->Traslados_;
  }

  void Impuestos::
  Traslados (const Traslados_type& x)
  {
    this->Traslados_.set (x);
  }

  void Impuestos::
  Traslados (const Traslados_optional& x)
  {
    this->Traslados_ = x;
  }

  void Impuestos::
  Traslados (::std::auto_ptr< Traslados_type > x)
  {
    this->Traslados_.set (x);
  }

  const Impuestos::TotalImpuestosRetenidos_optional& Impuestos::
  TotalImpuestosRetenidos () const
  {
    return this->TotalImpuestosRetenidos_;
  }

  Impuestos::TotalImpuestosRetenidos_optional& Impuestos::
  TotalImpuestosRetenidos ()
  {
    return this->TotalImpuestosRetenidos_;
  }

  void Impuestos::
  TotalImpuestosRetenidos (const TotalImpuestosRetenidos_type& x)
  {
    this->TotalImpuestosRetenidos_.set (x);
  }

  void Impuestos::
  TotalImpuestosRetenidos (const TotalImpuestosRetenidos_optional& x)
  {
    this->TotalImpuestosRetenidos_ = x;
  }

  void Impuestos::
  TotalImpuestosRetenidos (::std::auto_ptr< TotalImpuestosRetenidos_type > x)
  {
    this->TotalImpuestosRetenidos_.set (x);
  }

  const Impuestos::TotalImpuestosTrasladados_optional& Impuestos::
  TotalImpuestosTrasladados () const
  {
    return this->TotalImpuestosTrasladados_;
  }

  Impuestos::TotalImpuestosTrasladados_optional& Impuestos::
  TotalImpuestosTrasladados ()
  {
    return this->TotalImpuestosTrasladados_;
  }

  void Impuestos::
  TotalImpuestosTrasladados (const TotalImpuestosTrasladados_type& x)
  {
    this->TotalImpuestosTrasladados_.set (x);
  }

  void Impuestos::
  TotalImpuestosTrasladados (const TotalImpuestosTrasladados_optional& x)
  {
    this->TotalImpuestosTrasladados_ = x;
  }

  void Impuestos::
  TotalImpuestosTrasladados (::std::auto_ptr< TotalImpuestosTrasladados_type > x)
  {
    this->TotalImpuestosTrasladados_.set (x);
  }


  // Complemento
  // 


  // Addenda
  // 


  // Version
  // 


  // Serie
  // 


  // Folio
  // 


  // Sello
  // 


  // NoCertificado
  // 


  // Certificado
  // 


  // CondicionesDePago
  // 


  // TipoCambio
  // 


  // Confirmacion
  // 


  // CfdiRelacionado
  // 

  const CfdiRelacionado::UUID_type& CfdiRelacionado::
  UUID () const
  {
    return this->UUID_.get ();
  }

  CfdiRelacionado::UUID_type& CfdiRelacionado::
  UUID ()
  {
    return this->UUID_.get ();
  }

  void CfdiRelacionado::
  UUID (const UUID_type& x)
  {
    this->UUID_.set (x);
  }

  void CfdiRelacionado::
  UUID (::std::auto_ptr< UUID_type > x)
  {
    this->UUID_.set (x);
  }


  // Nombre
  // 


  // NumRegIdTrib
  // 


  // Concepto
  // 

  const Concepto::Impuestos_optional& Concepto::
  Impuestos () const
  {
    return this->Impuestos_;
  }

  Concepto::Impuestos_optional& Concepto::
  Impuestos ()
  {
    return this->Impuestos_;
  }

  void Concepto::
  Impuestos (const Impuestos_type& x)
  {
    this->Impuestos_.set (x);
  }

  void Concepto::
  Impuestos (const Impuestos_optional& x)
  {
    this->Impuestos_ = x;
  }

  void Concepto::
  Impuestos (::std::auto_ptr< Impuestos_type > x)
  {
    this->Impuestos_.set (x);
  }

  const Concepto::InformacionAduanera_sequence& Concepto::
  InformacionAduanera () const
  {
    return this->InformacionAduanera_;
  }

  Concepto::InformacionAduanera_sequence& Concepto::
  InformacionAduanera ()
  {
    return this->InformacionAduanera_;
  }

  void Concepto::
  InformacionAduanera (const InformacionAduanera_sequence& s)
  {
    this->InformacionAduanera_ = s;
  }

  const Concepto::CuentaPredial_optional& Concepto::
  CuentaPredial () const
  {
    return this->CuentaPredial_;
  }

  Concepto::CuentaPredial_optional& Concepto::
  CuentaPredial ()
  {
    return this->CuentaPredial_;
  }

  void Concepto::
  CuentaPredial (const CuentaPredial_type& x)
  {
    this->CuentaPredial_.set (x);
  }

  void Concepto::
  CuentaPredial (const CuentaPredial_optional& x)
  {
    this->CuentaPredial_ = x;
  }

  void Concepto::
  CuentaPredial (::std::auto_ptr< CuentaPredial_type > x)
  {
    this->CuentaPredial_.set (x);
  }

  const Concepto::ComplementoConcepto_optional& Concepto::
  ComplementoConcepto () const
  {
    return this->ComplementoConcepto_;
  }

  Concepto::ComplementoConcepto_optional& Concepto::
  ComplementoConcepto ()
  {
    return this->ComplementoConcepto_;
  }

  void Concepto::
  ComplementoConcepto (const ComplementoConcepto_type& x)
  {
    this->ComplementoConcepto_.set (x);
  }

  void Concepto::
  ComplementoConcepto (const ComplementoConcepto_optional& x)
  {
    this->ComplementoConcepto_ = x;
  }

  void Concepto::
  ComplementoConcepto (::std::auto_ptr< ComplementoConcepto_type > x)
  {
    this->ComplementoConcepto_.set (x);
  }

  const Concepto::Parte_sequence& Concepto::
  Parte () const
  {
    return this->Parte_;
  }

  Concepto::Parte_sequence& Concepto::
  Parte ()
  {
    return this->Parte_;
  }

  void Concepto::
  Parte (const Parte_sequence& s)
  {
    this->Parte_ = s;
  }

  const Concepto::ClaveProdServ_type& Concepto::
  ClaveProdServ () const
  {
    return this->ClaveProdServ_.get ();
  }

  Concepto::ClaveProdServ_type& Concepto::
  ClaveProdServ ()
  {
    return this->ClaveProdServ_.get ();
  }

  void Concepto::
  ClaveProdServ (const ClaveProdServ_type& x)
  {
    this->ClaveProdServ_.set (x);
  }

  void Concepto::
  ClaveProdServ (::std::auto_ptr< ClaveProdServ_type > x)
  {
    this->ClaveProdServ_.set (x);
  }

  const Concepto::NoIdentificacion_optional& Concepto::
  NoIdentificacion () const
  {
    return this->NoIdentificacion_;
  }

  Concepto::NoIdentificacion_optional& Concepto::
  NoIdentificacion ()
  {
    return this->NoIdentificacion_;
  }

  void Concepto::
  NoIdentificacion (const NoIdentificacion_type& x)
  {
    this->NoIdentificacion_.set (x);
  }

  void Concepto::
  NoIdentificacion (const NoIdentificacion_optional& x)
  {
    this->NoIdentificacion_ = x;
  }

  void Concepto::
  NoIdentificacion (::std::auto_ptr< NoIdentificacion_type > x)
  {
    this->NoIdentificacion_.set (x);
  }

  const Concepto::Cantidad_type& Concepto::
  Cantidad () const
  {
    return this->Cantidad_.get ();
  }

  Concepto::Cantidad_type& Concepto::
  Cantidad ()
  {
    return this->Cantidad_.get ();
  }

  void Concepto::
  Cantidad (const Cantidad_type& x)
  {
    this->Cantidad_.set (x);
  }

  void Concepto::
  Cantidad (::std::auto_ptr< Cantidad_type > x)
  {
    this->Cantidad_.set (x);
  }

  const Concepto::ClaveUnidad_type& Concepto::
  ClaveUnidad () const
  {
    return this->ClaveUnidad_.get ();
  }

  Concepto::ClaveUnidad_type& Concepto::
  ClaveUnidad ()
  {
    return this->ClaveUnidad_.get ();
  }

  void Concepto::
  ClaveUnidad (const ClaveUnidad_type& x)
  {
    this->ClaveUnidad_.set (x);
  }

  void Concepto::
  ClaveUnidad (::std::auto_ptr< ClaveUnidad_type > x)
  {
    this->ClaveUnidad_.set (x);
  }

  const Concepto::Unidad_optional& Concepto::
  Unidad () const
  {
    return this->Unidad_;
  }

  Concepto::Unidad_optional& Concepto::
  Unidad ()
  {
    return this->Unidad_;
  }

  void Concepto::
  Unidad (const Unidad_type& x)
  {
    this->Unidad_.set (x);
  }

  void Concepto::
  Unidad (const Unidad_optional& x)
  {
    this->Unidad_ = x;
  }

  void Concepto::
  Unidad (::std::auto_ptr< Unidad_type > x)
  {
    this->Unidad_.set (x);
  }

  const Concepto::Descripcion_type& Concepto::
  Descripcion () const
  {
    return this->Descripcion_.get ();
  }

  Concepto::Descripcion_type& Concepto::
  Descripcion ()
  {
    return this->Descripcion_.get ();
  }

  void Concepto::
  Descripcion (const Descripcion_type& x)
  {
    this->Descripcion_.set (x);
  }

  void Concepto::
  Descripcion (::std::auto_ptr< Descripcion_type > x)
  {
    this->Descripcion_.set (x);
  }

  const Concepto::ValorUnitario_type& Concepto::
  ValorUnitario () const
  {
    return this->ValorUnitario_.get ();
  }

  Concepto::ValorUnitario_type& Concepto::
  ValorUnitario ()
  {
    return this->ValorUnitario_.get ();
  }

  void Concepto::
  ValorUnitario (const ValorUnitario_type& x)
  {
    this->ValorUnitario_.set (x);
  }

  void Concepto::
  ValorUnitario (::std::auto_ptr< ValorUnitario_type > x)
  {
    this->ValorUnitario_.set (x);
  }

  const Concepto::Importe_type& Concepto::
  Importe () const
  {
    return this->Importe_.get ();
  }

  Concepto::Importe_type& Concepto::
  Importe ()
  {
    return this->Importe_.get ();
  }

  void Concepto::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Concepto::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }

  const Concepto::Descuento_optional& Concepto::
  Descuento () const
  {
    return this->Descuento_;
  }

  Concepto::Descuento_optional& Concepto::
  Descuento ()
  {
    return this->Descuento_;
  }

  void Concepto::
  Descuento (const Descuento_type& x)
  {
    this->Descuento_.set (x);
  }

  void Concepto::
  Descuento (const Descuento_optional& x)
  {
    this->Descuento_ = x;
  }

  void Concepto::
  Descuento (::std::auto_ptr< Descuento_type > x)
  {
    this->Descuento_.set (x);
  }


  // Retenciones
  // 

  const Retenciones::Retencion_sequence& Retenciones::
  Retencion () const
  {
    return this->Retencion_;
  }

  Retenciones::Retencion_sequence& Retenciones::
  Retencion ()
  {
    return this->Retencion_;
  }

  void Retenciones::
  Retencion (const Retencion_sequence& s)
  {
    this->Retencion_ = s;
  }


  // Traslados
  // 

  const Traslados::Traslado_sequence& Traslados::
  Traslado () const
  {
    return this->Traslado_;
  }

  Traslados::Traslado_sequence& Traslados::
  Traslado ()
  {
    return this->Traslado_;
  }

  void Traslados::
  Traslado (const Traslado_sequence& s)
  {
    this->Traslado_ = s;
  }


  // UUID
  // 


  // Impuestos1
  // 

  const Impuestos1::Traslados_optional& Impuestos1::
  Traslados () const
  {
    return this->Traslados_;
  }

  Impuestos1::Traslados_optional& Impuestos1::
  Traslados ()
  {
    return this->Traslados_;
  }

  void Impuestos1::
  Traslados (const Traslados_type& x)
  {
    this->Traslados_.set (x);
  }

  void Impuestos1::
  Traslados (const Traslados_optional& x)
  {
    this->Traslados_ = x;
  }

  void Impuestos1::
  Traslados (::std::auto_ptr< Traslados_type > x)
  {
    this->Traslados_.set (x);
  }

  const Impuestos1::Retenciones_optional& Impuestos1::
  Retenciones () const
  {
    return this->Retenciones_;
  }

  Impuestos1::Retenciones_optional& Impuestos1::
  Retenciones ()
  {
    return this->Retenciones_;
  }

  void Impuestos1::
  Retenciones (const Retenciones_type& x)
  {
    this->Retenciones_.set (x);
  }

  void Impuestos1::
  Retenciones (const Retenciones_optional& x)
  {
    this->Retenciones_ = x;
  }

  void Impuestos1::
  Retenciones (::std::auto_ptr< Retenciones_type > x)
  {
    this->Retenciones_.set (x);
  }


  // InformacionAduanera
  // 

  const InformacionAduanera::NumeroPedimento_type& InformacionAduanera::
  NumeroPedimento () const
  {
    return this->NumeroPedimento_.get ();
  }

  InformacionAduanera::NumeroPedimento_type& InformacionAduanera::
  NumeroPedimento ()
  {
    return this->NumeroPedimento_.get ();
  }

  void InformacionAduanera::
  NumeroPedimento (const NumeroPedimento_type& x)
  {
    this->NumeroPedimento_.set (x);
  }

  void InformacionAduanera::
  NumeroPedimento (::std::auto_ptr< NumeroPedimento_type > x)
  {
    this->NumeroPedimento_.set (x);
  }


  // CuentaPredial
  // 

  const CuentaPredial::Numero_type& CuentaPredial::
  Numero () const
  {
    return this->Numero_.get ();
  }

  CuentaPredial::Numero_type& CuentaPredial::
  Numero ()
  {
    return this->Numero_.get ();
  }

  void CuentaPredial::
  Numero (const Numero_type& x)
  {
    this->Numero_.set (x);
  }

  void CuentaPredial::
  Numero (::std::auto_ptr< Numero_type > x)
  {
    this->Numero_.set (x);
  }


  // ComplementoConcepto
  // 


  // Parte
  // 

  const Parte::InformacionAduanera_sequence& Parte::
  InformacionAduanera () const
  {
    return this->InformacionAduanera_;
  }

  Parte::InformacionAduanera_sequence& Parte::
  InformacionAduanera ()
  {
    return this->InformacionAduanera_;
  }

  void Parte::
  InformacionAduanera (const InformacionAduanera_sequence& s)
  {
    this->InformacionAduanera_ = s;
  }

  const Parte::ClaveProdServ_type& Parte::
  ClaveProdServ () const
  {
    return this->ClaveProdServ_.get ();
  }

  Parte::ClaveProdServ_type& Parte::
  ClaveProdServ ()
  {
    return this->ClaveProdServ_.get ();
  }

  void Parte::
  ClaveProdServ (const ClaveProdServ_type& x)
  {
    this->ClaveProdServ_.set (x);
  }

  void Parte::
  ClaveProdServ (::std::auto_ptr< ClaveProdServ_type > x)
  {
    this->ClaveProdServ_.set (x);
  }

  const Parte::NoIdentificacion_optional& Parte::
  NoIdentificacion () const
  {
    return this->NoIdentificacion_;
  }

  Parte::NoIdentificacion_optional& Parte::
  NoIdentificacion ()
  {
    return this->NoIdentificacion_;
  }

  void Parte::
  NoIdentificacion (const NoIdentificacion_type& x)
  {
    this->NoIdentificacion_.set (x);
  }

  void Parte::
  NoIdentificacion (const NoIdentificacion_optional& x)
  {
    this->NoIdentificacion_ = x;
  }

  void Parte::
  NoIdentificacion (::std::auto_ptr< NoIdentificacion_type > x)
  {
    this->NoIdentificacion_.set (x);
  }

  const Parte::Cantidad_type& Parte::
  Cantidad () const
  {
    return this->Cantidad_.get ();
  }

  Parte::Cantidad_type& Parte::
  Cantidad ()
  {
    return this->Cantidad_.get ();
  }

  void Parte::
  Cantidad (const Cantidad_type& x)
  {
    this->Cantidad_.set (x);
  }

  void Parte::
  Cantidad (::std::auto_ptr< Cantidad_type > x)
  {
    this->Cantidad_.set (x);
  }

  const Parte::Unidad_optional& Parte::
  Unidad () const
  {
    return this->Unidad_;
  }

  Parte::Unidad_optional& Parte::
  Unidad ()
  {
    return this->Unidad_;
  }

  void Parte::
  Unidad (const Unidad_type& x)
  {
    this->Unidad_.set (x);
  }

  void Parte::
  Unidad (const Unidad_optional& x)
  {
    this->Unidad_ = x;
  }

  void Parte::
  Unidad (::std::auto_ptr< Unidad_type > x)
  {
    this->Unidad_.set (x);
  }

  const Parte::Descripcion_type& Parte::
  Descripcion () const
  {
    return this->Descripcion_.get ();
  }

  Parte::Descripcion_type& Parte::
  Descripcion ()
  {
    return this->Descripcion_.get ();
  }

  void Parte::
  Descripcion (const Descripcion_type& x)
  {
    this->Descripcion_.set (x);
  }

  void Parte::
  Descripcion (::std::auto_ptr< Descripcion_type > x)
  {
    this->Descripcion_.set (x);
  }

  const Parte::ValorUnitario_optional& Parte::
  ValorUnitario () const
  {
    return this->ValorUnitario_;
  }

  Parte::ValorUnitario_optional& Parte::
  ValorUnitario ()
  {
    return this->ValorUnitario_;
  }

  void Parte::
  ValorUnitario (const ValorUnitario_type& x)
  {
    this->ValorUnitario_.set (x);
  }

  void Parte::
  ValorUnitario (const ValorUnitario_optional& x)
  {
    this->ValorUnitario_ = x;
  }

  void Parte::
  ValorUnitario (::std::auto_ptr< ValorUnitario_type > x)
  {
    this->ValorUnitario_.set (x);
  }

  const Parte::Importe_optional& Parte::
  Importe () const
  {
    return this->Importe_;
  }

  Parte::Importe_optional& Parte::
  Importe ()
  {
    return this->Importe_;
  }

  void Parte::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Parte::
  Importe (const Importe_optional& x)
  {
    this->Importe_ = x;
  }

  void Parte::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }


  // NoIdentificacion
  // 


  // Cantidad
  // 


  // Unidad
  // 


  // Descripcion
  // 


  // Retencion
  // 

  const Retencion::Impuesto_type& Retencion::
  Impuesto () const
  {
    return this->Impuesto_.get ();
  }

  Retencion::Impuesto_type& Retencion::
  Impuesto ()
  {
    return this->Impuesto_.get ();
  }

  void Retencion::
  Impuesto (const Impuesto_type& x)
  {
    this->Impuesto_.set (x);
  }

  void Retencion::
  Impuesto (::std::auto_ptr< Impuesto_type > x)
  {
    this->Impuesto_.set (x);
  }

  const Retencion::Importe_type& Retencion::
  Importe () const
  {
    return this->Importe_.get ();
  }

  Retencion::Importe_type& Retencion::
  Importe ()
  {
    return this->Importe_.get ();
  }

  void Retencion::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Retencion::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }


  // Traslado
  // 

  const Traslado::Impuesto_type& Traslado::
  Impuesto () const
  {
    return this->Impuesto_.get ();
  }

  Traslado::Impuesto_type& Traslado::
  Impuesto ()
  {
    return this->Impuesto_.get ();
  }

  void Traslado::
  Impuesto (const Impuesto_type& x)
  {
    this->Impuesto_.set (x);
  }

  void Traslado::
  Impuesto (::std::auto_ptr< Impuesto_type > x)
  {
    this->Impuesto_.set (x);
  }

  const Traslado::TipoFactor_type& Traslado::
  TipoFactor () const
  {
    return this->TipoFactor_.get ();
  }

  Traslado::TipoFactor_type& Traslado::
  TipoFactor ()
  {
    return this->TipoFactor_.get ();
  }

  void Traslado::
  TipoFactor (const TipoFactor_type& x)
  {
    this->TipoFactor_.set (x);
  }

  void Traslado::
  TipoFactor (::std::auto_ptr< TipoFactor_type > x)
  {
    this->TipoFactor_.set (x);
  }

  const Traslado::TasaOCuota_type& Traslado::
  TasaOCuota () const
  {
    return this->TasaOCuota_.get ();
  }

  Traslado::TasaOCuota_type& Traslado::
  TasaOCuota ()
  {
    return this->TasaOCuota_.get ();
  }

  void Traslado::
  TasaOCuota (const TasaOCuota_type& x)
  {
    this->TasaOCuota_.set (x);
  }

  void Traslado::
  TasaOCuota (::std::auto_ptr< TasaOCuota_type > x)
  {
    this->TasaOCuota_.set (x);
  }

  const Traslado::Importe_type& Traslado::
  Importe () const
  {
    return this->Importe_.get ();
  }

  Traslado::Importe_type& Traslado::
  Importe ()
  {
    return this->Importe_.get ();
  }

  void Traslado::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Traslado::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }


  // Traslados1
  // 

  const Traslados1::Traslado_sequence& Traslados1::
  Traslado () const
  {
    return this->Traslado_;
  }

  Traslados1::Traslado_sequence& Traslados1::
  Traslado ()
  {
    return this->Traslado_;
  }

  void Traslados1::
  Traslado (const Traslado_sequence& s)
  {
    this->Traslado_ = s;
  }


  // Retenciones1
  // 

  const Retenciones1::Retencion_sequence& Retenciones1::
  Retencion () const
  {
    return this->Retencion_;
  }

  Retenciones1::Retencion_sequence& Retenciones1::
  Retencion ()
  {
    return this->Retencion_;
  }

  void Retenciones1::
  Retencion (const Retencion_sequence& s)
  {
    this->Retencion_ = s;
  }


  // NumeroPedimento
  // 


  // Numero
  // 


  // InformacionAduanera1
  // 

  const InformacionAduanera1::NumeroPedimento_type& InformacionAduanera1::
  NumeroPedimento () const
  {
    return this->NumeroPedimento_.get ();
  }

  InformacionAduanera1::NumeroPedimento_type& InformacionAduanera1::
  NumeroPedimento ()
  {
    return this->NumeroPedimento_.get ();
  }

  void InformacionAduanera1::
  NumeroPedimento (const NumeroPedimento_type& x)
  {
    this->NumeroPedimento_.set (x);
  }

  void InformacionAduanera1::
  NumeroPedimento (::std::auto_ptr< NumeroPedimento_type > x)
  {
    this->NumeroPedimento_.set (x);
  }


  // TasaOCuota
  // 


  // Traslado1
  // 

  const Traslado1::Base_type& Traslado1::
  Base () const
  {
    return this->Base_.get ();
  }

  Traslado1::Base_type& Traslado1::
  Base ()
  {
    return this->Base_.get ();
  }

  void Traslado1::
  Base (const Base_type& x)
  {
    this->Base_.set (x);
  }

  void Traslado1::
  Base (::std::auto_ptr< Base_type > x)
  {
    this->Base_.set (x);
  }

  const Traslado1::Impuesto_type& Traslado1::
  Impuesto () const
  {
    return this->Impuesto_.get ();
  }

  Traslado1::Impuesto_type& Traslado1::
  Impuesto ()
  {
    return this->Impuesto_.get ();
  }

  void Traslado1::
  Impuesto (const Impuesto_type& x)
  {
    this->Impuesto_.set (x);
  }

  void Traslado1::
  Impuesto (::std::auto_ptr< Impuesto_type > x)
  {
    this->Impuesto_.set (x);
  }

  const Traslado1::TipoFactor_type& Traslado1::
  TipoFactor () const
  {
    return this->TipoFactor_.get ();
  }

  Traslado1::TipoFactor_type& Traslado1::
  TipoFactor ()
  {
    return this->TipoFactor_.get ();
  }

  void Traslado1::
  TipoFactor (const TipoFactor_type& x)
  {
    this->TipoFactor_.set (x);
  }

  void Traslado1::
  TipoFactor (::std::auto_ptr< TipoFactor_type > x)
  {
    this->TipoFactor_.set (x);
  }

  const Traslado1::TasaOCuota_optional& Traslado1::
  TasaOCuota () const
  {
    return this->TasaOCuota_;
  }

  Traslado1::TasaOCuota_optional& Traslado1::
  TasaOCuota ()
  {
    return this->TasaOCuota_;
  }

  void Traslado1::
  TasaOCuota (const TasaOCuota_type& x)
  {
    this->TasaOCuota_.set (x);
  }

  void Traslado1::
  TasaOCuota (const TasaOCuota_optional& x)
  {
    this->TasaOCuota_ = x;
  }

  void Traslado1::
  TasaOCuota (::std::auto_ptr< TasaOCuota_type > x)
  {
    this->TasaOCuota_.set (x);
  }

  const Traslado1::Importe_optional& Traslado1::
  Importe () const
  {
    return this->Importe_;
  }

  Traslado1::Importe_optional& Traslado1::
  Importe ()
  {
    return this->Importe_;
  }

  void Traslado1::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Traslado1::
  Importe (const Importe_optional& x)
  {
    this->Importe_ = x;
  }

  void Traslado1::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }


  // Retencion1
  // 

  const Retencion1::Base_type& Retencion1::
  Base () const
  {
    return this->Base_.get ();
  }

  Retencion1::Base_type& Retencion1::
  Base ()
  {
    return this->Base_.get ();
  }

  void Retencion1::
  Base (const Base_type& x)
  {
    this->Base_.set (x);
  }

  void Retencion1::
  Base (::std::auto_ptr< Base_type > x)
  {
    this->Base_.set (x);
  }

  const Retencion1::Impuesto_type& Retencion1::
  Impuesto () const
  {
    return this->Impuesto_.get ();
  }

  Retencion1::Impuesto_type& Retencion1::
  Impuesto ()
  {
    return this->Impuesto_.get ();
  }

  void Retencion1::
  Impuesto (const Impuesto_type& x)
  {
    this->Impuesto_.set (x);
  }

  void Retencion1::
  Impuesto (::std::auto_ptr< Impuesto_type > x)
  {
    this->Impuesto_.set (x);
  }

  const Retencion1::TipoFactor_type& Retencion1::
  TipoFactor () const
  {
    return this->TipoFactor_.get ();
  }

  Retencion1::TipoFactor_type& Retencion1::
  TipoFactor ()
  {
    return this->TipoFactor_.get ();
  }

  void Retencion1::
  TipoFactor (const TipoFactor_type& x)
  {
    this->TipoFactor_.set (x);
  }

  void Retencion1::
  TipoFactor (::std::auto_ptr< TipoFactor_type > x)
  {
    this->TipoFactor_.set (x);
  }

  const Retencion1::TasaOCuota_type& Retencion1::
  TasaOCuota () const
  {
    return this->TasaOCuota_.get ();
  }

  Retencion1::TasaOCuota_type& Retencion1::
  TasaOCuota ()
  {
    return this->TasaOCuota_.get ();
  }

  void Retencion1::
  TasaOCuota (const TasaOCuota_type& x)
  {
    this->TasaOCuota_.set (x);
  }

  void Retencion1::
  TasaOCuota (::std::auto_ptr< TasaOCuota_type > x)
  {
    this->TasaOCuota_.set (x);
  }

  const Retencion1::Importe_type& Retencion1::
  Importe () const
  {
    return this->Importe_.get ();
  }

  Retencion1::Importe_type& Retencion1::
  Importe ()
  {
    return this->Importe_.get ();
  }

  void Retencion1::
  Importe (const Importe_type& x)
  {
    this->Importe_.set (x);
  }

  void Retencion1::
  Importe (::std::auto_ptr< Importe_type > x)
  {
    this->Importe_.set (x);
  }


  // Base
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace XDSToXML
{
  // Comprobante
  //
  const Comprobante::Version_type Comprobante::Version_default_value_ (
    "3.3");

  Comprobante::
  Comprobante (const Emisor_type& Emisor,
               const Receptor_type& Receptor,
               const Conceptos_type& Conceptos,
               const Fecha_type& Fecha,
               const Sello_type& Sello,
               const NoCertificado_type& NoCertificado,
               const Certificado_type& Certificado,
               const SubTotal_type& SubTotal,
               const Moneda_type& Moneda,
               const Total_type& Total,
               const TipoDeComprobante_type& TipoDeComprobante,
               const LugarExpedicion_type& LugarExpedicion)
  : ::xml_schema::type (),
    CfdiRelacionados_ (this),
    Emisor_ (Emisor, this),
    Receptor_ (Receptor, this),
    Conceptos_ (Conceptos, this),
    Impuestos_ (this),
    Complemento_ (this),
    Addenda_ (this),
    Version_ (Version_default_value (), this),
    Serie_ (this),
    Folio_ (this),
    Fecha_ (Fecha, this),
    Sello_ (Sello, this),
    FormaPago_ (this),
    NoCertificado_ (NoCertificado, this),
    Certificado_ (Certificado, this),
    CondicionesDePago_ (this),
    SubTotal_ (SubTotal, this),
    Descuento_ (this),
    Moneda_ (Moneda, this),
    TipoCambio_ (this),
    Total_ (Total, this),
    TipoDeComprobante_ (TipoDeComprobante, this),
    MetodoPago_ (this),
    LugarExpedicion_ (LugarExpedicion, this),
    Confirmacion_ (this)
  {
  }

  Comprobante::
  Comprobante (::std::auto_ptr< Emisor_type > Emisor,
               ::std::auto_ptr< Receptor_type > Receptor,
               ::std::auto_ptr< Conceptos_type > Conceptos,
               const Fecha_type& Fecha,
               const Sello_type& Sello,
               const NoCertificado_type& NoCertificado,
               const Certificado_type& Certificado,
               const SubTotal_type& SubTotal,
               const Moneda_type& Moneda,
               const Total_type& Total,
               const TipoDeComprobante_type& TipoDeComprobante,
               const LugarExpedicion_type& LugarExpedicion)
  : ::xml_schema::type (),
    CfdiRelacionados_ (this),
    Emisor_ (Emisor, this),
    Receptor_ (Receptor, this),
    Conceptos_ (Conceptos, this),
    Impuestos_ (this),
    Complemento_ (this),
    Addenda_ (this),
    Version_ (Version_default_value (), this),
    Serie_ (this),
    Folio_ (this),
    Fecha_ (Fecha, this),
    Sello_ (Sello, this),
    FormaPago_ (this),
    NoCertificado_ (NoCertificado, this),
    Certificado_ (Certificado, this),
    CondicionesDePago_ (this),
    SubTotal_ (SubTotal, this),
    Descuento_ (this),
    Moneda_ (Moneda, this),
    TipoCambio_ (this),
    Total_ (Total, this),
    TipoDeComprobante_ (TipoDeComprobante, this),
    MetodoPago_ (this),
    LugarExpedicion_ (LugarExpedicion, this),
    Confirmacion_ (this)
  {
  }

  Comprobante::
  Comprobante (const Comprobante& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CfdiRelacionados_ (x.CfdiRelacionados_, f, this),
    Emisor_ (x.Emisor_, f, this),
    Receptor_ (x.Receptor_, f, this),
    Conceptos_ (x.Conceptos_, f, this),
    Impuestos_ (x.Impuestos_, f, this),
    Complemento_ (x.Complemento_, f, this),
    Addenda_ (x.Addenda_, f, this),
    Version_ (x.Version_, f, this),
    Serie_ (x.Serie_, f, this),
    Folio_ (x.Folio_, f, this),
    Fecha_ (x.Fecha_, f, this),
    Sello_ (x.Sello_, f, this),
    FormaPago_ (x.FormaPago_, f, this),
    NoCertificado_ (x.NoCertificado_, f, this),
    Certificado_ (x.Certificado_, f, this),
    CondicionesDePago_ (x.CondicionesDePago_, f, this),
    SubTotal_ (x.SubTotal_, f, this),
    Descuento_ (x.Descuento_, f, this),
    Moneda_ (x.Moneda_, f, this),
    TipoCambio_ (x.TipoCambio_, f, this),
    Total_ (x.Total_, f, this),
    TipoDeComprobante_ (x.TipoDeComprobante_, f, this),
    MetodoPago_ (x.MetodoPago_, f, this),
    LugarExpedicion_ (x.LugarExpedicion_, f, this),
    Confirmacion_ (x.Confirmacion_, f, this)
  {
  }

  Comprobante::
  Comprobante (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CfdiRelacionados_ (this),
    Emisor_ (this),
    Receptor_ (this),
    Conceptos_ (this),
    Impuestos_ (this),
    Complemento_ (this),
    Addenda_ (this),
    Version_ (this),
    Serie_ (this),
    Folio_ (this),
    Fecha_ (this),
    Sello_ (this),
    FormaPago_ (this),
    NoCertificado_ (this),
    Certificado_ (this),
    CondicionesDePago_ (this),
    SubTotal_ (this),
    Descuento_ (this),
    Moneda_ (this),
    TipoCambio_ (this),
    Total_ (this),
    TipoDeComprobante_ (this),
    MetodoPago_ (this),
    LugarExpedicion_ (this),
    Confirmacion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Comprobante::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CfdiRelacionados
      //
      if (n.name () == "CfdiRelacionados" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< CfdiRelacionados_type > r (
          CfdiRelacionados_traits::create (i, f, this));

        if (!this->CfdiRelacionados_)
        {
          this->CfdiRelacionados_.set (r);
          continue;
        }
      }

      // Emisor
      //
      if (n.name () == "Emisor" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Emisor_type > r (
          Emisor_traits::create (i, f, this));

        if (!Emisor_.present ())
        {
          this->Emisor_.set (r);
          continue;
        }
      }

      // Receptor
      //
      if (n.name () == "Receptor" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Receptor_type > r (
          Receptor_traits::create (i, f, this));

        if (!Receptor_.present ())
        {
          this->Receptor_.set (r);
          continue;
        }
      }

      // Conceptos
      //
      if (n.name () == "Conceptos" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Conceptos_type > r (
          Conceptos_traits::create (i, f, this));

        if (!Conceptos_.present ())
        {
          this->Conceptos_.set (r);
          continue;
        }
      }

      // Impuestos
      //
      if (n.name () == "Impuestos" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Impuestos_type > r (
          Impuestos_traits::create (i, f, this));

        if (!this->Impuestos_)
        {
          this->Impuestos_.set (r);
          continue;
        }
      }

      // Complemento
      //
      if (n.name () == "Complemento" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Complemento_type > r (
          Complemento_traits::create (i, f, this));

        this->Complemento_.push_back (r);
        continue;
      }

      // Addenda
      //
      if (n.name () == "Addenda" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Addenda_type > r (
          Addenda_traits::create (i, f, this));

        if (!this->Addenda_)
        {
          this->Addenda_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Emisor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Emisor",
        "XDSToXML");
    }

    if (!Receptor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Receptor",
        "XDSToXML");
    }

    if (!Conceptos_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Conceptos",
        "XDSToXML");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Version" && n.namespace_ ().empty ())
      {
        this->Version_.set (Version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Serie" && n.namespace_ ().empty ())
      {
        this->Serie_.set (Serie_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Folio" && n.namespace_ ().empty ())
      {
        this->Folio_.set (Folio_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Fecha" && n.namespace_ ().empty ())
      {
        this->Fecha_.set (Fecha_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Sello" && n.namespace_ ().empty ())
      {
        this->Sello_.set (Sello_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "FormaPago" && n.namespace_ ().empty ())
      {
        this->FormaPago_.set (FormaPago_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "NoCertificado" && n.namespace_ ().empty ())
      {
        this->NoCertificado_.set (NoCertificado_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Certificado" && n.namespace_ ().empty ())
      {
        this->Certificado_.set (Certificado_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "CondicionesDePago" && n.namespace_ ().empty ())
      {
        this->CondicionesDePago_.set (CondicionesDePago_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "SubTotal" && n.namespace_ ().empty ())
      {
        this->SubTotal_.set (SubTotal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Descuento" && n.namespace_ ().empty ())
      {
        this->Descuento_.set (Descuento_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Moneda" && n.namespace_ ().empty ())
      {
        this->Moneda_.set (Moneda_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TipoCambio" && n.namespace_ ().empty ())
      {
        this->TipoCambio_.set (TipoCambio_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Total" && n.namespace_ ().empty ())
      {
        this->Total_.set (Total_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TipoDeComprobante" && n.namespace_ ().empty ())
      {
        this->TipoDeComprobante_.set (TipoDeComprobante_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "MetodoPago" && n.namespace_ ().empty ())
      {
        this->MetodoPago_.set (MetodoPago_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "LugarExpedicion" && n.namespace_ ().empty ())
      {
        this->LugarExpedicion_.set (LugarExpedicion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Confirmacion" && n.namespace_ ().empty ())
      {
        this->Confirmacion_.set (Confirmacion_traits::create (i, f, this));
        continue;
      }
    }

    if (!Version_.present ())
    {
      this->Version_.set (Version_default_value ());
    }

    if (!Fecha_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Fecha",
        "");
    }

    if (!Sello_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Sello",
        "");
    }

    if (!NoCertificado_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "NoCertificado",
        "");
    }

    if (!Certificado_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Certificado",
        "");
    }

    if (!SubTotal_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SubTotal",
        "");
    }

    if (!Moneda_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Moneda",
        "");
    }

    if (!Total_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Total",
        "");
    }

    if (!TipoDeComprobante_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TipoDeComprobante",
        "");
    }

    if (!LugarExpedicion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "LugarExpedicion",
        "");
    }
  }

  Comprobante* Comprobante::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Comprobante (*this, f, c);
  }

  Comprobante& Comprobante::
  operator= (const Comprobante& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CfdiRelacionados_ = x.CfdiRelacionados_;
      this->Emisor_ = x.Emisor_;
      this->Receptor_ = x.Receptor_;
      this->Conceptos_ = x.Conceptos_;
      this->Impuestos_ = x.Impuestos_;
      this->Complemento_ = x.Complemento_;
      this->Addenda_ = x.Addenda_;
      this->Version_ = x.Version_;
      this->Serie_ = x.Serie_;
      this->Folio_ = x.Folio_;
      this->Fecha_ = x.Fecha_;
      this->Sello_ = x.Sello_;
      this->FormaPago_ = x.FormaPago_;
      this->NoCertificado_ = x.NoCertificado_;
      this->Certificado_ = x.Certificado_;
      this->CondicionesDePago_ = x.CondicionesDePago_;
      this->SubTotal_ = x.SubTotal_;
      this->Descuento_ = x.Descuento_;
      this->Moneda_ = x.Moneda_;
      this->TipoCambio_ = x.TipoCambio_;
      this->Total_ = x.Total_;
      this->TipoDeComprobante_ = x.TipoDeComprobante_;
      this->MetodoPago_ = x.MetodoPago_;
      this->LugarExpedicion_ = x.LugarExpedicion_;
      this->Confirmacion_ = x.Confirmacion_;
    }

    return *this;
  }

  Comprobante::
  ~Comprobante ()
  {
  }

  // CfdiRelacionados
  //

  CfdiRelacionados::
  CfdiRelacionados (const TipoRelacion_type& TipoRelacion)
  : ::xml_schema::type (),
    CfdiRelacionado_ (this),
    TipoRelacion_ (TipoRelacion, this)
  {
  }

  CfdiRelacionados::
  CfdiRelacionados (const CfdiRelacionados& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CfdiRelacionado_ (x.CfdiRelacionado_, f, this),
    TipoRelacion_ (x.TipoRelacion_, f, this)
  {
  }

  CfdiRelacionados::
  CfdiRelacionados (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CfdiRelacionado_ (this),
    TipoRelacion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CfdiRelacionados::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CfdiRelacionado
      //
      if (n.name () == "CfdiRelacionado" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< CfdiRelacionado_type > r (
          CfdiRelacionado_traits::create (i, f, this));

        this->CfdiRelacionado_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "TipoRelacion" && n.namespace_ ().empty ())
      {
        this->TipoRelacion_.set (TipoRelacion_traits::create (i, f, this));
        continue;
      }
    }

    if (!TipoRelacion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TipoRelacion",
        "");
    }
  }

  CfdiRelacionados* CfdiRelacionados::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CfdiRelacionados (*this, f, c);
  }

  CfdiRelacionados& CfdiRelacionados::
  operator= (const CfdiRelacionados& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CfdiRelacionado_ = x.CfdiRelacionado_;
      this->TipoRelacion_ = x.TipoRelacion_;
    }

    return *this;
  }

  CfdiRelacionados::
  ~CfdiRelacionados ()
  {
  }

  // Emisor
  //

  Emisor::
  Emisor (const Rfc_type& Rfc,
          const RegimenFiscal_type& RegimenFiscal)
  : ::xml_schema::type (),
    Rfc_ (Rfc, this),
    Nombre_ (this),
    RegimenFiscal_ (RegimenFiscal, this)
  {
  }

  Emisor::
  Emisor (const Emisor& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Rfc_ (x.Rfc_, f, this),
    Nombre_ (x.Nombre_, f, this),
    RegimenFiscal_ (x.RegimenFiscal_, f, this)
  {
  }

  Emisor::
  Emisor (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Rfc_ (this),
    Nombre_ (this),
    RegimenFiscal_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Emisor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Rfc" && n.namespace_ ().empty ())
      {
        this->Rfc_.set (Rfc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Nombre" && n.namespace_ ().empty ())
      {
        this->Nombre_.set (Nombre_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "RegimenFiscal" && n.namespace_ ().empty ())
      {
        this->RegimenFiscal_.set (RegimenFiscal_traits::create (i, f, this));
        continue;
      }
    }

    if (!Rfc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Rfc",
        "");
    }

    if (!RegimenFiscal_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "RegimenFiscal",
        "");
    }
  }

  Emisor* Emisor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Emisor (*this, f, c);
  }

  Emisor& Emisor::
  operator= (const Emisor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Rfc_ = x.Rfc_;
      this->Nombre_ = x.Nombre_;
      this->RegimenFiscal_ = x.RegimenFiscal_;
    }

    return *this;
  }

  Emisor::
  ~Emisor ()
  {
  }

  // Receptor
  //

  Receptor::
  Receptor (const Rfc_type& Rfc,
            const UsoCFDI_type& UsoCFDI)
  : ::xml_schema::type (),
    Rfc_ (Rfc, this),
    Nombre_ (this),
    ResidenciaFiscal_ (this),
    NumRegIdTrib_ (this),
    UsoCFDI_ (UsoCFDI, this)
  {
  }

  Receptor::
  Receptor (const Receptor& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Rfc_ (x.Rfc_, f, this),
    Nombre_ (x.Nombre_, f, this),
    ResidenciaFiscal_ (x.ResidenciaFiscal_, f, this),
    NumRegIdTrib_ (x.NumRegIdTrib_, f, this),
    UsoCFDI_ (x.UsoCFDI_, f, this)
  {
  }

  Receptor::
  Receptor (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Rfc_ (this),
    Nombre_ (this),
    ResidenciaFiscal_ (this),
    NumRegIdTrib_ (this),
    UsoCFDI_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Receptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Rfc" && n.namespace_ ().empty ())
      {
        this->Rfc_.set (Rfc_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Nombre" && n.namespace_ ().empty ())
      {
        this->Nombre_.set (Nombre_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ResidenciaFiscal" && n.namespace_ ().empty ())
      {
        this->ResidenciaFiscal_.set (ResidenciaFiscal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "NumRegIdTrib" && n.namespace_ ().empty ())
      {
        this->NumRegIdTrib_.set (NumRegIdTrib_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "UsoCFDI" && n.namespace_ ().empty ())
      {
        this->UsoCFDI_.set (UsoCFDI_traits::create (i, f, this));
        continue;
      }
    }

    if (!Rfc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Rfc",
        "");
    }

    if (!UsoCFDI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "UsoCFDI",
        "");
    }
  }

  Receptor* Receptor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Receptor (*this, f, c);
  }

  Receptor& Receptor::
  operator= (const Receptor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Rfc_ = x.Rfc_;
      this->Nombre_ = x.Nombre_;
      this->ResidenciaFiscal_ = x.ResidenciaFiscal_;
      this->NumRegIdTrib_ = x.NumRegIdTrib_;
      this->UsoCFDI_ = x.UsoCFDI_;
    }

    return *this;
  }

  Receptor::
  ~Receptor ()
  {
  }

  // Conceptos
  //

  Conceptos::
  Conceptos ()
  : ::xml_schema::type (),
    Concepto_ (this)
  {
  }

  Conceptos::
  Conceptos (const Conceptos& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Concepto_ (x.Concepto_, f, this)
  {
  }

  Conceptos::
  Conceptos (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Concepto_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Conceptos::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Concepto
      //
      if (n.name () == "Concepto" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Concepto_type > r (
          Concepto_traits::create (i, f, this));

        this->Concepto_.push_back (r);
        continue;
      }

      break;
    }
  }

  Conceptos* Conceptos::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Conceptos (*this, f, c);
  }

  Conceptos& Conceptos::
  operator= (const Conceptos& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Concepto_ = x.Concepto_;
    }

    return *this;
  }

  Conceptos::
  ~Conceptos ()
  {
  }

  // Impuestos
  //

  Impuestos::
  Impuestos ()
  : ::xml_schema::type (),
    Retenciones_ (this),
    Traslados_ (this),
    TotalImpuestosRetenidos_ (this),
    TotalImpuestosTrasladados_ (this)
  {
  }

  Impuestos::
  Impuestos (const Impuestos& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Retenciones_ (x.Retenciones_, f, this),
    Traslados_ (x.Traslados_, f, this),
    TotalImpuestosRetenidos_ (x.TotalImpuestosRetenidos_, f, this),
    TotalImpuestosTrasladados_ (x.TotalImpuestosTrasladados_, f, this)
  {
  }

  Impuestos::
  Impuestos (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Retenciones_ (this),
    Traslados_ (this),
    TotalImpuestosRetenidos_ (this),
    TotalImpuestosTrasladados_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Impuestos::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Retenciones
      //
      if (n.name () == "Retenciones" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Retenciones_type > r (
          Retenciones_traits::create (i, f, this));

        if (!this->Retenciones_)
        {
          this->Retenciones_.set (r);
          continue;
        }
      }

      // Traslados
      //
      if (n.name () == "Traslados" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Traslados_type > r (
          Traslados_traits::create (i, f, this));

        if (!this->Traslados_)
        {
          this->Traslados_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "TotalImpuestosRetenidos" && n.namespace_ ().empty ())
      {
        this->TotalImpuestosRetenidos_.set (TotalImpuestosRetenidos_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TotalImpuestosTrasladados" && n.namespace_ ().empty ())
      {
        this->TotalImpuestosTrasladados_.set (TotalImpuestosTrasladados_traits::create (i, f, this));
        continue;
      }
    }
  }

  Impuestos* Impuestos::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Impuestos (*this, f, c);
  }

  Impuestos& Impuestos::
  operator= (const Impuestos& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Retenciones_ = x.Retenciones_;
      this->Traslados_ = x.Traslados_;
      this->TotalImpuestosRetenidos_ = x.TotalImpuestosRetenidos_;
      this->TotalImpuestosTrasladados_ = x.TotalImpuestosTrasladados_;
    }

    return *this;
  }

  Impuestos::
  ~Impuestos ()
  {
  }

  // Complemento
  //

  Complemento::
  Complemento ()
  : ::xml_schema::type ()
  {
  }

  Complemento::
  Complemento (const Complemento& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Complemento::
  Complemento (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Complemento::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  Complemento* Complemento::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Complemento (*this, f, c);
  }

  Complemento::
  ~Complemento ()
  {
  }

  // Addenda
  //

  Addenda::
  Addenda ()
  : ::xml_schema::type ()
  {
  }

  Addenda::
  Addenda (const Addenda& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Addenda::
  Addenda (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Addenda::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  Addenda* Addenda::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Addenda (*this, f, c);
  }

  Addenda::
  ~Addenda ()
  {
  }

  // Version
  //

  Version::
  Version ()
  : ::xml_schema::string ()
  {
  }

  Version::
  Version (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const Version& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Version::
  Version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Version* Version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Version (*this, f, c);
  }

  Version::
  ~Version ()
  {
  }

  // Serie
  //

  Serie::
  Serie ()
  : ::xml_schema::string ()
  {
  }

  Serie::
  Serie (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Serie::
  Serie (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Serie::
  Serie (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Serie::
  Serie (const Serie& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Serie::
  Serie (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Serie::
  Serie (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Serie::
  Serie (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Serie* Serie::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Serie (*this, f, c);
  }

  Serie::
  ~Serie ()
  {
  }

  // Folio
  //

  Folio::
  Folio ()
  : ::xml_schema::string ()
  {
  }

  Folio::
  Folio (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Folio::
  Folio (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Folio::
  Folio (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Folio::
  Folio (const Folio& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Folio::
  Folio (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Folio::
  Folio (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Folio::
  Folio (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Folio* Folio::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Folio (*this, f, c);
  }

  Folio::
  ~Folio ()
  {
  }

  // Sello
  //

  Sello::
  Sello ()
  : ::xml_schema::string ()
  {
  }

  Sello::
  Sello (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Sello::
  Sello (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Sello::
  Sello (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Sello::
  Sello (const Sello& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Sello::
  Sello (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Sello::
  Sello (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Sello::
  Sello (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Sello* Sello::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Sello (*this, f, c);
  }

  Sello::
  ~Sello ()
  {
  }

  // NoCertificado
  //

  NoCertificado::
  NoCertificado ()
  : ::xml_schema::string ()
  {
  }

  NoCertificado::
  NoCertificado (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoCertificado::
  NoCertificado (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoCertificado::
  NoCertificado (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoCertificado::
  NoCertificado (const NoCertificado& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NoCertificado::
  NoCertificado (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NoCertificado::
  NoCertificado (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NoCertificado::
  NoCertificado (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NoCertificado* NoCertificado::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NoCertificado (*this, f, c);
  }

  NoCertificado::
  ~NoCertificado ()
  {
  }

  // Certificado
  //

  Certificado::
  Certificado ()
  : ::xml_schema::string ()
  {
  }

  Certificado::
  Certificado (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Certificado::
  Certificado (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Certificado::
  Certificado (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Certificado::
  Certificado (const Certificado& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Certificado::
  Certificado (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Certificado::
  Certificado (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Certificado::
  Certificado (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Certificado* Certificado::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Certificado (*this, f, c);
  }

  Certificado::
  ~Certificado ()
  {
  }

  // CondicionesDePago
  //

  CondicionesDePago::
  CondicionesDePago ()
  : ::xml_schema::string ()
  {
  }

  CondicionesDePago::
  CondicionesDePago (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const CondicionesDePago& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  CondicionesDePago::
  CondicionesDePago (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  CondicionesDePago* CondicionesDePago::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CondicionesDePago (*this, f, c);
  }

  CondicionesDePago::
  ~CondicionesDePago ()
  {
  }

  // TipoCambio
  //

  static const ::xsd::cxx::tree::facet _xsd_TipoCambio_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  TipoCambio::
  TipoCambio (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_TipoCambio_facet_table);
  }

  TipoCambio::
  TipoCambio (const TipoCambio& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_TipoCambio_facet_table);
  }

  TipoCambio::
  TipoCambio (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_TipoCambio_facet_table);
  }

  TipoCambio::
  TipoCambio (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_TipoCambio_facet_table);
  }

  TipoCambio::
  TipoCambio (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_TipoCambio_facet_table);
  }

  TipoCambio* TipoCambio::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TipoCambio (*this, f, c);
  }

  TipoCambio::
  ~TipoCambio ()
  {
  }

  // Confirmacion
  //

  Confirmacion::
  Confirmacion ()
  : ::xml_schema::string ()
  {
  }

  Confirmacion::
  Confirmacion (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Confirmacion::
  Confirmacion (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Confirmacion::
  Confirmacion (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Confirmacion::
  Confirmacion (const Confirmacion& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Confirmacion::
  Confirmacion (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Confirmacion::
  Confirmacion (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Confirmacion::
  Confirmacion (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Confirmacion* Confirmacion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Confirmacion (*this, f, c);
  }

  Confirmacion::
  ~Confirmacion ()
  {
  }

  // CfdiRelacionado
  //

  CfdiRelacionado::
  CfdiRelacionado (const UUID_type& UUID)
  : ::xml_schema::type (),
    UUID_ (UUID, this)
  {
  }

  CfdiRelacionado::
  CfdiRelacionado (const CfdiRelacionado& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UUID_ (x.UUID_, f, this)
  {
  }

  CfdiRelacionado::
  CfdiRelacionado (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UUID_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CfdiRelacionado::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "UUID" && n.namespace_ ().empty ())
      {
        this->UUID_.set (UUID_traits::create (i, f, this));
        continue;
      }
    }

    if (!UUID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "UUID",
        "");
    }
  }

  CfdiRelacionado* CfdiRelacionado::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CfdiRelacionado (*this, f, c);
  }

  CfdiRelacionado& CfdiRelacionado::
  operator= (const CfdiRelacionado& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->UUID_ = x.UUID_;
    }

    return *this;
  }

  CfdiRelacionado::
  ~CfdiRelacionado ()
  {
  }

  // Nombre
  //

  Nombre::
  Nombre ()
  : ::xml_schema::string ()
  {
  }

  Nombre::
  Nombre (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nombre::
  Nombre (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nombre::
  Nombre (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Nombre::
  Nombre (const Nombre& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Nombre::
  Nombre (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Nombre::
  Nombre (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Nombre::
  Nombre (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Nombre* Nombre::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nombre (*this, f, c);
  }

  Nombre::
  ~Nombre ()
  {
  }

  // NumRegIdTrib
  //

  NumRegIdTrib::
  NumRegIdTrib ()
  : ::xml_schema::string ()
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const NumRegIdTrib& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NumRegIdTrib::
  NumRegIdTrib (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NumRegIdTrib* NumRegIdTrib::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NumRegIdTrib (*this, f, c);
  }

  NumRegIdTrib::
  ~NumRegIdTrib ()
  {
  }

  // Concepto
  //

  Concepto::
  Concepto (const ClaveProdServ_type& ClaveProdServ,
            const Cantidad_type& Cantidad,
            const ClaveUnidad_type& ClaveUnidad,
            const Descripcion_type& Descripcion,
            const ValorUnitario_type& ValorUnitario,
            const Importe_type& Importe)
  : ::xml_schema::type (),
    Impuestos_ (this),
    InformacionAduanera_ (this),
    CuentaPredial_ (this),
    ComplementoConcepto_ (this),
    Parte_ (this),
    ClaveProdServ_ (ClaveProdServ, this),
    NoIdentificacion_ (this),
    Cantidad_ (Cantidad, this),
    ClaveUnidad_ (ClaveUnidad, this),
    Unidad_ (this),
    Descripcion_ (Descripcion, this),
    ValorUnitario_ (ValorUnitario, this),
    Importe_ (Importe, this),
    Descuento_ (this)
  {
  }

  Concepto::
  Concepto (const Concepto& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Impuestos_ (x.Impuestos_, f, this),
    InformacionAduanera_ (x.InformacionAduanera_, f, this),
    CuentaPredial_ (x.CuentaPredial_, f, this),
    ComplementoConcepto_ (x.ComplementoConcepto_, f, this),
    Parte_ (x.Parte_, f, this),
    ClaveProdServ_ (x.ClaveProdServ_, f, this),
    NoIdentificacion_ (x.NoIdentificacion_, f, this),
    Cantidad_ (x.Cantidad_, f, this),
    ClaveUnidad_ (x.ClaveUnidad_, f, this),
    Unidad_ (x.Unidad_, f, this),
    Descripcion_ (x.Descripcion_, f, this),
    ValorUnitario_ (x.ValorUnitario_, f, this),
    Importe_ (x.Importe_, f, this),
    Descuento_ (x.Descuento_, f, this)
  {
  }

  Concepto::
  Concepto (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Impuestos_ (this),
    InformacionAduanera_ (this),
    CuentaPredial_ (this),
    ComplementoConcepto_ (this),
    Parte_ (this),
    ClaveProdServ_ (this),
    NoIdentificacion_ (this),
    Cantidad_ (this),
    ClaveUnidad_ (this),
    Unidad_ (this),
    Descripcion_ (this),
    ValorUnitario_ (this),
    Importe_ (this),
    Descuento_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Concepto::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Impuestos
      //
      if (n.name () == "Impuestos" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Impuestos_type > r (
          Impuestos_traits::create (i, f, this));

        if (!this->Impuestos_)
        {
          this->Impuestos_.set (r);
          continue;
        }
      }

      // InformacionAduanera
      //
      if (n.name () == "InformacionAduanera" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< InformacionAduanera_type > r (
          InformacionAduanera_traits::create (i, f, this));

        this->InformacionAduanera_.push_back (r);
        continue;
      }

      // CuentaPredial
      //
      if (n.name () == "CuentaPredial" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< CuentaPredial_type > r (
          CuentaPredial_traits::create (i, f, this));

        if (!this->CuentaPredial_)
        {
          this->CuentaPredial_.set (r);
          continue;
        }
      }

      // ComplementoConcepto
      //
      if (n.name () == "ComplementoConcepto" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< ComplementoConcepto_type > r (
          ComplementoConcepto_traits::create (i, f, this));

        if (!this->ComplementoConcepto_)
        {
          this->ComplementoConcepto_.set (r);
          continue;
        }
      }

      // Parte
      //
      if (n.name () == "Parte" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Parte_type > r (
          Parte_traits::create (i, f, this));

        this->Parte_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ClaveProdServ" && n.namespace_ ().empty ())
      {
        this->ClaveProdServ_.set (ClaveProdServ_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "NoIdentificacion" && n.namespace_ ().empty ())
      {
        this->NoIdentificacion_.set (NoIdentificacion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Cantidad" && n.namespace_ ().empty ())
      {
        this->Cantidad_.set (Cantidad_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ClaveUnidad" && n.namespace_ ().empty ())
      {
        this->ClaveUnidad_.set (ClaveUnidad_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Unidad" && n.namespace_ ().empty ())
      {
        this->Unidad_.set (Unidad_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Descripcion" && n.namespace_ ().empty ())
      {
        this->Descripcion_.set (Descripcion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ValorUnitario" && n.namespace_ ().empty ())
      {
        this->ValorUnitario_.set (ValorUnitario_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Descuento" && n.namespace_ ().empty ())
      {
        this->Descuento_.set (Descuento_traits::create (i, f, this));
        continue;
      }
    }

    if (!ClaveProdServ_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ClaveProdServ",
        "");
    }

    if (!Cantidad_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Cantidad",
        "");
    }

    if (!ClaveUnidad_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ClaveUnidad",
        "");
    }

    if (!Descripcion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Descripcion",
        "");
    }

    if (!ValorUnitario_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ValorUnitario",
        "");
    }

    if (!Importe_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Importe",
        "");
    }
  }

  Concepto* Concepto::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Concepto (*this, f, c);
  }

  Concepto& Concepto::
  operator= (const Concepto& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Impuestos_ = x.Impuestos_;
      this->InformacionAduanera_ = x.InformacionAduanera_;
      this->CuentaPredial_ = x.CuentaPredial_;
      this->ComplementoConcepto_ = x.ComplementoConcepto_;
      this->Parte_ = x.Parte_;
      this->ClaveProdServ_ = x.ClaveProdServ_;
      this->NoIdentificacion_ = x.NoIdentificacion_;
      this->Cantidad_ = x.Cantidad_;
      this->ClaveUnidad_ = x.ClaveUnidad_;
      this->Unidad_ = x.Unidad_;
      this->Descripcion_ = x.Descripcion_;
      this->ValorUnitario_ = x.ValorUnitario_;
      this->Importe_ = x.Importe_;
      this->Descuento_ = x.Descuento_;
    }

    return *this;
  }

  Concepto::
  ~Concepto ()
  {
  }

  // Retenciones
  //

  Retenciones::
  Retenciones ()
  : ::xml_schema::type (),
    Retencion_ (this)
  {
  }

  Retenciones::
  Retenciones (const Retenciones& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Retencion_ (x.Retencion_, f, this)
  {
  }

  Retenciones::
  Retenciones (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Retencion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Retenciones::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Retencion
      //
      if (n.name () == "Retencion" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Retencion_type > r (
          Retencion_traits::create (i, f, this));

        this->Retencion_.push_back (r);
        continue;
      }

      break;
    }
  }

  Retenciones* Retenciones::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Retenciones (*this, f, c);
  }

  Retenciones& Retenciones::
  operator= (const Retenciones& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Retencion_ = x.Retencion_;
    }

    return *this;
  }

  Retenciones::
  ~Retenciones ()
  {
  }

  // Traslados
  //

  Traslados::
  Traslados ()
  : ::xml_schema::type (),
    Traslado_ (this)
  {
  }

  Traslados::
  Traslados (const Traslados& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Traslado_ (x.Traslado_, f, this)
  {
  }

  Traslados::
  Traslados (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Traslado_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Traslados::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Traslado
      //
      if (n.name () == "Traslado" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Traslado_type > r (
          Traslado_traits::create (i, f, this));

        this->Traslado_.push_back (r);
        continue;
      }

      break;
    }
  }

  Traslados* Traslados::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Traslados (*this, f, c);
  }

  Traslados& Traslados::
  operator= (const Traslados& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Traslado_ = x.Traslado_;
    }

    return *this;
  }

  Traslados::
  ~Traslados ()
  {
  }

  // UUID
  //

  UUID::
  UUID ()
  : ::xml_schema::string ()
  {
  }

  UUID::
  UUID (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UUID::
  UUID (const UUID& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  UUID::
  UUID (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  UUID::
  UUID (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  UUID::
  UUID (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  UUID* UUID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UUID (*this, f, c);
  }

  UUID::
  ~UUID ()
  {
  }

  // Impuestos1
  //

  Impuestos1::
  Impuestos1 ()
  : ::xml_schema::type (),
    Traslados_ (this),
    Retenciones_ (this)
  {
  }

  Impuestos1::
  Impuestos1 (const Impuestos1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Traslados_ (x.Traslados_, f, this),
    Retenciones_ (x.Retenciones_, f, this)
  {
  }

  Impuestos1::
  Impuestos1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Traslados_ (this),
    Retenciones_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Impuestos1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Traslados
      //
      if (n.name () == "Traslados" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Traslados_type > r (
          Traslados_traits::create (i, f, this));

        if (!this->Traslados_)
        {
          this->Traslados_.set (r);
          continue;
        }
      }

      // Retenciones
      //
      if (n.name () == "Retenciones" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Retenciones_type > r (
          Retenciones_traits::create (i, f, this));

        if (!this->Retenciones_)
        {
          this->Retenciones_.set (r);
          continue;
        }
      }

      break;
    }
  }

  Impuestos1* Impuestos1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Impuestos1 (*this, f, c);
  }

  Impuestos1& Impuestos1::
  operator= (const Impuestos1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Traslados_ = x.Traslados_;
      this->Retenciones_ = x.Retenciones_;
    }

    return *this;
  }

  Impuestos1::
  ~Impuestos1 ()
  {
  }

  // InformacionAduanera
  //

  InformacionAduanera::
  InformacionAduanera (const NumeroPedimento_type& NumeroPedimento)
  : ::xml_schema::type (),
    NumeroPedimento_ (NumeroPedimento, this)
  {
  }

  InformacionAduanera::
  InformacionAduanera (const InformacionAduanera& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    NumeroPedimento_ (x.NumeroPedimento_, f, this)
  {
  }

  InformacionAduanera::
  InformacionAduanera (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    NumeroPedimento_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InformacionAduanera::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "NumeroPedimento" && n.namespace_ ().empty ())
      {
        this->NumeroPedimento_.set (NumeroPedimento_traits::create (i, f, this));
        continue;
      }
    }

    if (!NumeroPedimento_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "NumeroPedimento",
        "");
    }
  }

  InformacionAduanera* InformacionAduanera::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InformacionAduanera (*this, f, c);
  }

  InformacionAduanera& InformacionAduanera::
  operator= (const InformacionAduanera& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->NumeroPedimento_ = x.NumeroPedimento_;
    }

    return *this;
  }

  InformacionAduanera::
  ~InformacionAduanera ()
  {
  }

  // CuentaPredial
  //

  CuentaPredial::
  CuentaPredial (const Numero_type& Numero)
  : ::xml_schema::type (),
    Numero_ (Numero, this)
  {
  }

  CuentaPredial::
  CuentaPredial (const CuentaPredial& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Numero_ (x.Numero_, f, this)
  {
  }

  CuentaPredial::
  CuentaPredial (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Numero_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CuentaPredial::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Numero" && n.namespace_ ().empty ())
      {
        this->Numero_.set (Numero_traits::create (i, f, this));
        continue;
      }
    }

    if (!Numero_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Numero",
        "");
    }
  }

  CuentaPredial* CuentaPredial::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CuentaPredial (*this, f, c);
  }

  CuentaPredial& CuentaPredial::
  operator= (const CuentaPredial& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Numero_ = x.Numero_;
    }

    return *this;
  }

  CuentaPredial::
  ~CuentaPredial ()
  {
  }

  // ComplementoConcepto
  //

  ComplementoConcepto::
  ComplementoConcepto ()
  : ::xml_schema::type ()
  {
  }

  ComplementoConcepto::
  ComplementoConcepto (const ComplementoConcepto& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  ComplementoConcepto::
  ComplementoConcepto (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ComplementoConcepto::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  ComplementoConcepto* ComplementoConcepto::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComplementoConcepto (*this, f, c);
  }

  ComplementoConcepto::
  ~ComplementoConcepto ()
  {
  }

  // Parte
  //

  Parte::
  Parte (const ClaveProdServ_type& ClaveProdServ,
         const Cantidad_type& Cantidad,
         const Descripcion_type& Descripcion)
  : ::xml_schema::type (),
    InformacionAduanera_ (this),
    ClaveProdServ_ (ClaveProdServ, this),
    NoIdentificacion_ (this),
    Cantidad_ (Cantidad, this),
    Unidad_ (this),
    Descripcion_ (Descripcion, this),
    ValorUnitario_ (this),
    Importe_ (this)
  {
  }

  Parte::
  Parte (const Parte& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    InformacionAduanera_ (x.InformacionAduanera_, f, this),
    ClaveProdServ_ (x.ClaveProdServ_, f, this),
    NoIdentificacion_ (x.NoIdentificacion_, f, this),
    Cantidad_ (x.Cantidad_, f, this),
    Unidad_ (x.Unidad_, f, this),
    Descripcion_ (x.Descripcion_, f, this),
    ValorUnitario_ (x.ValorUnitario_, f, this),
    Importe_ (x.Importe_, f, this)
  {
  }

  Parte::
  Parte (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    InformacionAduanera_ (this),
    ClaveProdServ_ (this),
    NoIdentificacion_ (this),
    Cantidad_ (this),
    Unidad_ (this),
    Descripcion_ (this),
    ValorUnitario_ (this),
    Importe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Parte::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InformacionAduanera
      //
      if (n.name () == "InformacionAduanera" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< InformacionAduanera_type > r (
          InformacionAduanera_traits::create (i, f, this));

        this->InformacionAduanera_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ClaveProdServ" && n.namespace_ ().empty ())
      {
        this->ClaveProdServ_.set (ClaveProdServ_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "NoIdentificacion" && n.namespace_ ().empty ())
      {
        this->NoIdentificacion_.set (NoIdentificacion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Cantidad" && n.namespace_ ().empty ())
      {
        this->Cantidad_.set (Cantidad_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Unidad" && n.namespace_ ().empty ())
      {
        this->Unidad_.set (Unidad_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Descripcion" && n.namespace_ ().empty ())
      {
        this->Descripcion_.set (Descripcion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ValorUnitario" && n.namespace_ ().empty ())
      {
        this->ValorUnitario_.set (ValorUnitario_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }
    }

    if (!ClaveProdServ_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ClaveProdServ",
        "");
    }

    if (!Cantidad_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Cantidad",
        "");
    }

    if (!Descripcion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Descripcion",
        "");
    }
  }

  Parte* Parte::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Parte (*this, f, c);
  }

  Parte& Parte::
  operator= (const Parte& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->InformacionAduanera_ = x.InformacionAduanera_;
      this->ClaveProdServ_ = x.ClaveProdServ_;
      this->NoIdentificacion_ = x.NoIdentificacion_;
      this->Cantidad_ = x.Cantidad_;
      this->Unidad_ = x.Unidad_;
      this->Descripcion_ = x.Descripcion_;
      this->ValorUnitario_ = x.ValorUnitario_;
      this->Importe_ = x.Importe_;
    }

    return *this;
  }

  Parte::
  ~Parte ()
  {
  }

  // NoIdentificacion
  //

  NoIdentificacion::
  NoIdentificacion ()
  : ::xml_schema::string ()
  {
  }

  NoIdentificacion::
  NoIdentificacion (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const NoIdentificacion& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NoIdentificacion::
  NoIdentificacion (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NoIdentificacion* NoIdentificacion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NoIdentificacion (*this, f, c);
  }

  NoIdentificacion::
  ~NoIdentificacion ()
  {
  }

  // Cantidad
  //

  static const ::xsd::cxx::tree::facet _xsd_Cantidad_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  Cantidad::
  Cantidad (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_Cantidad_facet_table);
  }

  Cantidad::
  Cantidad (const Cantidad& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_Cantidad_facet_table);
  }

  Cantidad::
  Cantidad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_Cantidad_facet_table);
  }

  Cantidad::
  Cantidad (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_Cantidad_facet_table);
  }

  Cantidad::
  Cantidad (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_Cantidad_facet_table);
  }

  Cantidad* Cantidad::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Cantidad (*this, f, c);
  }

  Cantidad::
  ~Cantidad ()
  {
  }

  // Unidad
  //

  Unidad::
  Unidad ()
  : ::xml_schema::string ()
  {
  }

  Unidad::
  Unidad (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Unidad::
  Unidad (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Unidad::
  Unidad (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Unidad::
  Unidad (const Unidad& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Unidad::
  Unidad (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Unidad::
  Unidad (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Unidad::
  Unidad (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Unidad* Unidad::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Unidad (*this, f, c);
  }

  Unidad::
  ~Unidad ()
  {
  }

  // Descripcion
  //

  Descripcion::
  Descripcion ()
  : ::xml_schema::string ()
  {
  }

  Descripcion::
  Descripcion (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Descripcion::
  Descripcion (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Descripcion::
  Descripcion (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Descripcion::
  Descripcion (const Descripcion& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Descripcion::
  Descripcion (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Descripcion::
  Descripcion (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Descripcion::
  Descripcion (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Descripcion* Descripcion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Descripcion (*this, f, c);
  }

  Descripcion::
  ~Descripcion ()
  {
  }

  // Retencion
  //

  Retencion::
  Retencion (const Impuesto_type& Impuesto,
             const Importe_type& Importe)
  : ::xml_schema::type (),
    Impuesto_ (Impuesto, this),
    Importe_ (Importe, this)
  {
  }

  Retencion::
  Retencion (const Retencion& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Impuesto_ (x.Impuesto_, f, this),
    Importe_ (x.Importe_, f, this)
  {
  }

  Retencion::
  Retencion (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Impuesto_ (this),
    Importe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Retencion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Impuesto" && n.namespace_ ().empty ())
      {
        this->Impuesto_.set (Impuesto_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }
    }

    if (!Impuesto_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Impuesto",
        "");
    }

    if (!Importe_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Importe",
        "");
    }
  }

  Retencion* Retencion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Retencion (*this, f, c);
  }

  Retencion& Retencion::
  operator= (const Retencion& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Impuesto_ = x.Impuesto_;
      this->Importe_ = x.Importe_;
    }

    return *this;
  }

  Retencion::
  ~Retencion ()
  {
  }

  // Traslado
  //

  Traslado::
  Traslado (const Impuesto_type& Impuesto,
            const TipoFactor_type& TipoFactor,
            const TasaOCuota_type& TasaOCuota,
            const Importe_type& Importe)
  : ::xml_schema::type (),
    Impuesto_ (Impuesto, this),
    TipoFactor_ (TipoFactor, this),
    TasaOCuota_ (TasaOCuota, this),
    Importe_ (Importe, this)
  {
  }

  Traslado::
  Traslado (const Traslado& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Impuesto_ (x.Impuesto_, f, this),
    TipoFactor_ (x.TipoFactor_, f, this),
    TasaOCuota_ (x.TasaOCuota_, f, this),
    Importe_ (x.Importe_, f, this)
  {
  }

  Traslado::
  Traslado (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Impuesto_ (this),
    TipoFactor_ (this),
    TasaOCuota_ (this),
    Importe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Traslado::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Impuesto" && n.namespace_ ().empty ())
      {
        this->Impuesto_.set (Impuesto_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TipoFactor" && n.namespace_ ().empty ())
      {
        this->TipoFactor_.set (TipoFactor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TasaOCuota" && n.namespace_ ().empty ())
      {
        this->TasaOCuota_.set (TasaOCuota_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }
    }

    if (!Impuesto_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Impuesto",
        "");
    }

    if (!TipoFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TipoFactor",
        "");
    }

    if (!TasaOCuota_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TasaOCuota",
        "");
    }

    if (!Importe_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Importe",
        "");
    }
  }

  Traslado* Traslado::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Traslado (*this, f, c);
  }

  Traslado& Traslado::
  operator= (const Traslado& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Impuesto_ = x.Impuesto_;
      this->TipoFactor_ = x.TipoFactor_;
      this->TasaOCuota_ = x.TasaOCuota_;
      this->Importe_ = x.Importe_;
    }

    return *this;
  }

  Traslado::
  ~Traslado ()
  {
  }

  // Traslados1
  //

  Traslados1::
  Traslados1 ()
  : ::xml_schema::type (),
    Traslado_ (this)
  {
  }

  Traslados1::
  Traslados1 (const Traslados1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Traslado_ (x.Traslado_, f, this)
  {
  }

  Traslados1::
  Traslados1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Traslado_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Traslados1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Traslado
      //
      if (n.name () == "Traslado" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Traslado_type > r (
          Traslado_traits::create (i, f, this));

        this->Traslado_.push_back (r);
        continue;
      }

      break;
    }
  }

  Traslados1* Traslados1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Traslados1 (*this, f, c);
  }

  Traslados1& Traslados1::
  operator= (const Traslados1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Traslado_ = x.Traslado_;
    }

    return *this;
  }

  Traslados1::
  ~Traslados1 ()
  {
  }

  // Retenciones1
  //

  Retenciones1::
  Retenciones1 ()
  : ::xml_schema::type (),
    Retencion_ (this)
  {
  }

  Retenciones1::
  Retenciones1 (const Retenciones1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Retencion_ (x.Retencion_, f, this)
  {
  }

  Retenciones1::
  Retenciones1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Retencion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Retenciones1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Retencion
      //
      if (n.name () == "Retencion" && n.namespace_ () == "XDSToXML")
      {
        ::std::auto_ptr< Retencion_type > r (
          Retencion_traits::create (i, f, this));

        this->Retencion_.push_back (r);
        continue;
      }

      break;
    }
  }

  Retenciones1* Retenciones1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Retenciones1 (*this, f, c);
  }

  Retenciones1& Retenciones1::
  operator= (const Retenciones1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Retencion_ = x.Retencion_;
    }

    return *this;
  }

  Retenciones1::
  ~Retenciones1 ()
  {
  }

  // NumeroPedimento
  //

  NumeroPedimento::
  NumeroPedimento ()
  : ::xml_schema::string ()
  {
  }

  NumeroPedimento::
  NumeroPedimento (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const NumeroPedimento& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  NumeroPedimento::
  NumeroPedimento (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  NumeroPedimento* NumeroPedimento::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NumeroPedimento (*this, f, c);
  }

  NumeroPedimento::
  ~NumeroPedimento ()
  {
  }

  // Numero
  //

  Numero::
  Numero ()
  : ::xml_schema::string ()
  {
  }

  Numero::
  Numero (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Numero::
  Numero (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Numero::
  Numero (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Numero::
  Numero (const Numero& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Numero::
  Numero (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Numero::
  Numero (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Numero::
  Numero (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Numero* Numero::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Numero (*this, f, c);
  }

  Numero::
  ~Numero ()
  {
  }

  // InformacionAduanera1
  //

  InformacionAduanera1::
  InformacionAduanera1 (const NumeroPedimento_type& NumeroPedimento)
  : ::xml_schema::type (),
    NumeroPedimento_ (NumeroPedimento, this)
  {
  }

  InformacionAduanera1::
  InformacionAduanera1 (const InformacionAduanera1& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    NumeroPedimento_ (x.NumeroPedimento_, f, this)
  {
  }

  InformacionAduanera1::
  InformacionAduanera1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    NumeroPedimento_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InformacionAduanera1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "NumeroPedimento" && n.namespace_ ().empty ())
      {
        this->NumeroPedimento_.set (NumeroPedimento_traits::create (i, f, this));
        continue;
      }
    }

    if (!NumeroPedimento_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "NumeroPedimento",
        "");
    }
  }

  InformacionAduanera1* InformacionAduanera1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InformacionAduanera1 (*this, f, c);
  }

  InformacionAduanera1& InformacionAduanera1::
  operator= (const InformacionAduanera1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->NumeroPedimento_ = x.NumeroPedimento_;
    }

    return *this;
  }

  InformacionAduanera1::
  ~InformacionAduanera1 ()
  {
  }

  // TasaOCuota
  //

  static const ::xsd::cxx::tree::facet _xsd_TasaOCuota_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  TasaOCuota::
  TasaOCuota (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_TasaOCuota_facet_table);
  }

  TasaOCuota::
  TasaOCuota (const TasaOCuota& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_TasaOCuota_facet_table);
  }

  TasaOCuota::
  TasaOCuota (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_TasaOCuota_facet_table);
  }

  TasaOCuota::
  TasaOCuota (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_TasaOCuota_facet_table);
  }

  TasaOCuota::
  TasaOCuota (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_TasaOCuota_facet_table);
  }

  TasaOCuota* TasaOCuota::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TasaOCuota (*this, f, c);
  }

  TasaOCuota::
  ~TasaOCuota ()
  {
  }

  // Traslado1
  //

  Traslado1::
  Traslado1 (const Base_type& Base,
             const Impuesto_type& Impuesto,
             const TipoFactor_type& TipoFactor)
  : ::xml_schema::type (),
    Base_ (Base, this),
    Impuesto_ (Impuesto, this),
    TipoFactor_ (TipoFactor, this),
    TasaOCuota_ (this),
    Importe_ (this)
  {
  }

  Traslado1::
  Traslado1 (const Traslado1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Base_ (x.Base_, f, this),
    Impuesto_ (x.Impuesto_, f, this),
    TipoFactor_ (x.TipoFactor_, f, this),
    TasaOCuota_ (x.TasaOCuota_, f, this),
    Importe_ (x.Importe_, f, this)
  {
  }

  Traslado1::
  Traslado1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Base_ (this),
    Impuesto_ (this),
    TipoFactor_ (this),
    TasaOCuota_ (this),
    Importe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Traslado1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Base" && n.namespace_ ().empty ())
      {
        this->Base_.set (Base_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Impuesto" && n.namespace_ ().empty ())
      {
        this->Impuesto_.set (Impuesto_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TipoFactor" && n.namespace_ ().empty ())
      {
        this->TipoFactor_.set (TipoFactor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TasaOCuota" && n.namespace_ ().empty ())
      {
        this->TasaOCuota_.set (TasaOCuota_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }
    }

    if (!Base_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Base",
        "");
    }

    if (!Impuesto_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Impuesto",
        "");
    }

    if (!TipoFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TipoFactor",
        "");
    }
  }

  Traslado1* Traslado1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Traslado1 (*this, f, c);
  }

  Traslado1& Traslado1::
  operator= (const Traslado1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Base_ = x.Base_;
      this->Impuesto_ = x.Impuesto_;
      this->TipoFactor_ = x.TipoFactor_;
      this->TasaOCuota_ = x.TasaOCuota_;
      this->Importe_ = x.Importe_;
    }

    return *this;
  }

  Traslado1::
  ~Traslado1 ()
  {
  }

  // Retencion1
  //

  Retencion1::
  Retencion1 (const Base_type& Base,
              const Impuesto_type& Impuesto,
              const TipoFactor_type& TipoFactor,
              const TasaOCuota_type& TasaOCuota,
              const Importe_type& Importe)
  : ::xml_schema::type (),
    Base_ (Base, this),
    Impuesto_ (Impuesto, this),
    TipoFactor_ (TipoFactor, this),
    TasaOCuota_ (TasaOCuota, this),
    Importe_ (Importe, this)
  {
  }

  Retencion1::
  Retencion1 (const Retencion1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Base_ (x.Base_, f, this),
    Impuesto_ (x.Impuesto_, f, this),
    TipoFactor_ (x.TipoFactor_, f, this),
    TasaOCuota_ (x.TasaOCuota_, f, this),
    Importe_ (x.Importe_, f, this)
  {
  }

  Retencion1::
  Retencion1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Base_ (this),
    Impuesto_ (this),
    TipoFactor_ (this),
    TasaOCuota_ (this),
    Importe_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Retencion1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Base" && n.namespace_ ().empty ())
      {
        this->Base_.set (Base_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Impuesto" && n.namespace_ ().empty ())
      {
        this->Impuesto_.set (Impuesto_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TipoFactor" && n.namespace_ ().empty ())
      {
        this->TipoFactor_.set (TipoFactor_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "TasaOCuota" && n.namespace_ ().empty ())
      {
        this->TasaOCuota_.set (TasaOCuota_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Importe" && n.namespace_ ().empty ())
      {
        this->Importe_.set (Importe_traits::create (i, f, this));
        continue;
      }
    }

    if (!Base_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Base",
        "");
    }

    if (!Impuesto_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Impuesto",
        "");
    }

    if (!TipoFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TipoFactor",
        "");
    }

    if (!TasaOCuota_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TasaOCuota",
        "");
    }

    if (!Importe_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Importe",
        "");
    }
  }

  Retencion1* Retencion1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Retencion1 (*this, f, c);
  }

  Retencion1& Retencion1::
  operator= (const Retencion1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Base_ = x.Base_;
      this->Impuesto_ = x.Impuesto_;
      this->TipoFactor_ = x.TipoFactor_;
      this->TasaOCuota_ = x.TasaOCuota_;
      this->Importe_ = x.Importe_;
    }

    return *this;
  }

  Retencion1::
  ~Retencion1 ()
  {
  }

  // Base
  //

  static const ::xsd::cxx::tree::facet _xsd_Base_facet_table[] = 
  {
    {
      ::xsd::cxx::tree::facet::fraction_digits, 6UL
    },

    {
      ::xsd::cxx::tree::facet::none, 0UL
    }
  };

  Base::
  Base (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
    this->_facet_table (_xsd_Base_facet_table);
  }

  Base::
  Base (const Base& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
    this->_facet_table (_xsd_Base_facet_table);
  }

  Base::
  Base (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
    this->_facet_table (_xsd_Base_facet_table);
  }

  Base::
  Base (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
    this->_facet_table (_xsd_Base_facet_table);
  }

  Base::
  Base (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
    this->_facet_table (_xsd_Base_facet_table);
  }

  Base* Base::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Base (*this, f, c);
  }

  Base::
  ~Base ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XDSToXML
{
  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XDSToXML::Comprobante_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XDSToXML::Comprobante_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XDSToXML::Comprobante_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XDSToXML::Comprobante_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XDSToXML::Comprobante_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XDSToXML::Comprobante_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::XDSToXML::Comprobante > (
      ::XDSToXML::Comprobante_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::XDSToXML::Comprobante > (
        ::XDSToXML::Comprobante_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Comprobante" &&
        n.namespace_ () == "XDSToXML")
    {
      ::std::auto_ptr< ::XDSToXML::Comprobante > r (
        ::xsd::cxx::tree::traits< ::XDSToXML::Comprobante, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Comprobante",
      "XDSToXML");
  }

  ::std::auto_ptr< ::XDSToXML::Comprobante >
  Comprobante_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Comprobante" &&
        n.namespace_ () == "XDSToXML")
    {
      ::std::auto_ptr< ::XDSToXML::Comprobante > r (
        ::xsd::cxx::tree::traits< ::XDSToXML::Comprobante, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Comprobante",
      "XDSToXML");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

